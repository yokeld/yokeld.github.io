<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小夜灯</title>
  
  <subtitle>想看群星闪耀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-11T16:09:26.259Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>iXiAo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[设计模式]工厂模式</title>
    <link href="http://yoursite.com/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-05-11T03:35:40.000Z</published>
    <updated>2020-05-11T16:09:26.259Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式属于创建型设计模式， 其主要思想是将对象的创建和对象的调用分离。典型的工厂模式有三种， 分别是： <strong>简单工厂</strong>、<strong>工厂方法</strong>、<strong>抽象工厂</strong>， 其中<strong>简单工厂</strong>是<strong>工厂方法</strong>的一种特例， 或者说工厂方法是在为了解决简单工厂的缺陷而提出来的。</p><a id="more"></a><h2 id="0-理解"><a href="#0-理解" class="headerlink" title="0. 理解"></a>0. 理解</h2><p>本文尝试从社会角色的角度来看待工厂模式。</p><p>简单工厂的角色：</p><ul><li>需求方： 使用资源的人， 值知道资源的名称和资源的使用方式， 并提供获取资源所必要的信息</li><li>资源中介： 调度资源的人， 根据外界指定的资源名称和相关信息， 返回一个满足要求的资源对象</li><li>资源： 提供具体服务的对象</li></ul><p>在程序开发过程中， 业务代码相当于需求方下需求， 因此， 期待的调用过程是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line">named_resource = input(<span class="string">"指定使用资源： "</span>)</span><br><span class="line">resource = intermediary.order(named_resource, **init_params)</span><br><span class="line">resource.use()</span><br></pre></td></tr></table></figure><p>对于简单工厂而言， <code>intermediary</code>提供不同的资源， 即负责解决创建什么实例的问题， 从实现功能的角度而言， 直接由需求方创建实例也是可以的， 但是这样的程序不好扩展和维护：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line">named_resource = input(<span class="string">"指定使用资源： "</span>)</span><br><span class="line"><span class="keyword">if</span> named_resource == <span class="string">"ResourceA"</span>:</span><br><span class="line">    resource = ResA()</span><br><span class="line"><span class="keyword">elif</span> named_resource == <span class="string">"ResourceB"</span>:</span><br><span class="line">    resource = ResB()</span><br><span class="line"><span class="keyword">elif</span> named_resource == <span class="string">"ResourceC"</span>:</span><br><span class="line">    resource = ResC()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"没有该资源"</span>)</span><br><span class="line">resource.use()</span><br></pre></td></tr></table></figure><p>简单工厂模式其实是将流程控制这部分抽离出来了（FP），当新增资源时， 客户端部分的代码不需要修改， 只需要新增相应的资源类以及修改对应的简单工厂即可， 在python中， 通过利用自省， 甚至可以不需要修改工厂方法。</p><p>简单工厂模式的一个典型案例是实现一个计算器， 接下来通过这一场景来演示简单工厂模式的实现。</p><p>工厂方法模式的角色：</p><p><em>TODO</em></p><h2 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1. 简单工厂"></a>1. 简单工厂</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式属于创建型设计模式， 其主要思想是将对象的创建和对象的调用分离。典型的工厂模式有三种， 分别是： &lt;strong&gt;简单工厂&lt;/strong&gt;、&lt;strong&gt;工厂方法&lt;/strong&gt;、&lt;strong&gt;抽象工厂&lt;/strong&gt;， 其中&lt;strong&gt;简单工厂&lt;/strong&gt;是&lt;strong&gt;工厂方法&lt;/strong&gt;的一种特例， 或者说工厂方法是在为了解决简单工厂的缺陷而提出来的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/05/08/hello-world/"/>
    <id>http://yoursite.com/2020/05/08/hello-world/</id>
    <published>2020-05-08T13:05:33.855Z</published>
    <updated>2020-05-08T13:36:56.171Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="How-To-Write"><a href="#How-To-Write" class="headerlink" title="How To Write"></a>How To Write</h3><p>More info: <a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">Document</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[数据库] 指南</title>
    <link href="http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%8C%87%E5%8D%97/</id>
    <published>2020-05-07T16:35:15.000Z</published>
    <updated>2020-05-08T13:05:33.856Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[数据结构和算法] 指南</title>
    <link href="http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E6%8C%87%E5%8D%97/</id>
    <published>2020-05-07T16:34:57.000Z</published>
    <updated>2020-05-08T13:05:33.856Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python后端面试相关问题整理</title>
    <link href="http://yoursite.com/2020/05/08/Python%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/08/Python%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2020-05-07T16:32:53.000Z</published>
    <updated>2020-05-17T16:37:14.204Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文将整理 Python后端面试相关的比较重要的问题， 并列出主要相关知识点， 作为回答问题时的思路参考。</p></blockquote><a id="more"></a><h2 id="Part-1-Python-语言知识相关问题"><a href="#Part-1-Python-语言知识相关问题" class="headerlink" title="Part 1: Python 语言知识相关问题"></a>Part 1: Python 语言知识相关问题</h2><p><strong>本节内容梳理 python 编程语言相关的知识点， 主要包括语言特性、设计模式和具体领域编程相关的问题（主要是 网络编程， 重要知识点为 socket 编程相关问题、并行并发相关的问题以及几个主流框架的理解问题）</strong></p><h3 id="1-1-Python-语言相比其他语言的优点和缺点"><a href="#1-1-Python-语言相比其他语言的优点和缺点" class="headerlink" title="1.1 Python 语言相比其他语言的优点和缺点"></a>1.1 Python 语言相比其他语言的优点和缺点</h3><blockquote><p>总结，在语言的抉择上，我们可以从类型系统的静态检查，动态检查，检查范围及类型是否可变这几个维度来考虑，<strong>在开发效率，执行效率及安全性之间做权衡</strong>。无类型的语言可以很安全，但是可维护性差，基本被排除在系统开发之外。_&lt;出自参考文章1&gt;_</p><p>参考文章： </p><ol><li><a href="https://www.techug.com/post/choose-a-programming-language.html" target="_blank" rel="noopener">https://www.techug.com/post/choose-a-programming-language.html</a> </li><li><a href="https://blog.teamtreehouse.com/choose-programming-language" target="_blank" rel="noopener">https://blog.teamtreehouse.com/choose-programming-language</a> </li><li><a href="https://stackoverflow.com/questions/8070181/how-to-choose-a-programming-paradigm-to-work-with" target="_blank" rel="noopener">https://stackoverflow.com/questions/8070181/how-to-choose-a-programming-paradigm-to-work-with</a> </li><li><a href="https://zhuanlan.zhihu.com/p/34200056" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34200056</a> </li></ol></blockquote><p>语言的优势劣势都是具体到编程任务而言的，不同的业务场景、编程任务、开发平台，甚至历史遗留因素以及用工环境都可能会影响开发语言的选择。比如web开发， 国内java开发人员人数较多， 开发实践成熟， 因此java可以说是最佳的首选语言。但是如果是功能相对较简单、用户数不大的内部web项目， 只能投入较少的人力， 这个时候就会考虑用 python 的相关web框架来搭建。从实际落地的角度来讲， 有些时候会考虑当前团队的技术栈情况， 优先考虑团队熟悉的语言。</p><p>编程语言选型时可以先从业务角度遴选出可选编程语言， 然后再从技术角度确定使用哪种编程语言。</p><p>以下从技术角度和业务角度来看开发语言选型的问题， 从这个角度， 更加客观的看待不同语言的优劣。</p><p>从技术的角度考量三个大维度（简化优先考量）： 类型系统、语法、编程范式支持。 </p><p><strong>语言技术选型考量表：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注： </span><br><span class="line">A. 所有语言都支持动态检查（运行时检查）， 因此<span class="code">`静态[动态]检查`</span>一栏实际是考量是否有静态检查机制。</span><br><span class="line">B. 这里说明下强类型和弱类型的定义，强类型是指一旦被指定类型， 不可变， 弱类型则可变（包括隐式和显式两种）。</span><br><span class="line">C. 编程范式缩写：</span><br><span class="line"><span class="code">IP：指令式编程， 代表——汇编</span></span><br><span class="line"><span class="code">SP：结构化编程，通过for、while等此类结构化的代码来进行流程控制</span></span><br><span class="line"><span class="code">PP：过程是编程，特点是函数封装， 函数调用</span></span><br><span class="line"><span class="code">OOP：面向对象编程， 将对数据和操作封装在一起</span></span><br><span class="line"><span class="code">FP：函数式编程，特点——隐藏SP逻辑（尤其是控制流程）， 例 map(function, array)</span></span><br><span class="line"><span class="code">MP：元编程， 元编程是一种可以将程序当作数据来操作的技术，元编程能够读取，生成，分析或转换其他的程序代码，甚至可以在运行时修改自身 。</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>语言</th><th>类型系统</th><th>静态[动态]检查</th><th>强类型检测</th><th>弱/强类型</th><th>静态/动态类型</th><th>实现的类型理论</th><th>编程范式支持</th></tr></thead><tbody><tr><td>java</td><td>√</td><td>√</td><td>√</td><td>强类型</td><td>静态类型</td><td>泛型/多态/重载</td><td>IP,<br />SP,<br />PP,<br />OOP,<br />FP,<br />MP</td></tr><tr><td>python</td><td>√</td><td>√</td><td>×</td><td>弱类型</td><td>动态类型</td><td>鸭子类型/多态/重载</td><td>IP,<br />PP,<br />OOP,<br />FP,<br />MP</td></tr><tr><td>GO</td><td>√</td><td>√</td><td>√</td><td>强类型</td><td>静态类型</td><td>鸭子类型</td><td>IP,<br />PP,<br />MP</td></tr></tbody></table><p><strong>语言业务场景选型参考：</strong></p><table><thead><tr><th>语言</th><th>优势业务场景</th></tr></thead><tbody><tr><td>C / C++</td><td>操作系统、软件、库</td></tr><tr><td>JAVA</td><td>跨平台桌面应用程序、web应用程序服务端、android</td></tr><tr><td>swift</td><td>MAC OS X 应用程序、iOS应用程序</td></tr><tr><td>C#</td><td>WINDOWS桌面应用程序、MS、web应用程序</td></tr><tr><td>PHP</td><td>web应用程序服务端</td></tr><tr><td>Perl</td><td>一般脚本、字符串处理</td></tr><tr><td>Python</td><td>通用脚本、web应用程序服务端、数学和科学应用程序、Linux桌面应用程序</td></tr><tr><td>Ruby</td><td>通用脚本、web应用程序服务端</td></tr><tr><td>JavaScript</td><td>web应用程序客户端</td></tr></tbody></table><h3 id="1-2-什么是鸭子类型"><a href="#1-2-什么是鸭子类型" class="headerlink" title="1.2 什么是鸭子类型"></a>1.2 什么是鸭子类型</h3><p>鸭子类型是一种类型理论， 这个理论更加关注对象的外部行为而非内部结构。鸭子类型也是多态的一种形式，在这种形式中， 不管对象属于哪个类， 也不管声明的具体接口是什么， 只要对象实现了相应的方法， 函数就可以在对象上执行。</p><p>鸭子类型并非python独有， 而是python的类型系统实践了这一类型理论。GoLang同样支持鸭子类型。对于python而言， 函数使用传入对象时， 只要对象拥有相应的属性或方法， 程序就可以运行；对于GoLang而言， 只要传入的参数（结构体）有拥有声明的接口， 程序就可以通过编译。</p><p>python 基本上可以说处处体现了鸭子类型的运用。全部的类基本都默认继承了 object 的 __str__ 方法， 所有全部对象都可以作为 print 函数的参数； 任何实现了__getitem__的对象都支持索引语法。</p><h3 id="1-3-什么是猴子补丁技术？什么场景下可以使用猴子补丁？有哪些案例？"><a href="#1-3-什么是猴子补丁技术？什么场景下可以使用猴子补丁？有哪些案例？" class="headerlink" title="1.3 什么是猴子补丁技术？什么场景下可以使用猴子补丁？有哪些案例？"></a>1.3 什么是猴子补丁技术？什么场景下可以使用猴子补丁？有哪些案例？</h3><p>猴子补丁技术本质上是利用动态编程语言可以在程序运行时修改程序结构这一特点， 在运行时修改对象的属性和方法。gevent在这方面的运用比较多。不鼓励多用。</p><h3 id="1-4-什么是自省（内省）？有什么用处？"><a href="#1-4-什么是自省（内省）？有什么用处？" class="headerlink" title="1.4 什么是自省（内省）？有什么用处？"></a>1.4 什么是自省（内省）？有什么用处？</h3><blockquote><p>参考资料： <a href="https://www.bnmetrics.com/blog/introspection-reflection-in-python" target="_blank" rel="noopener">https://www.bnmetrics.com/blog/introspection-reflection-in-python</a> </p></blockquote><p>自省和反射是不同的。python同时有自省和反射的概念。通常说自省， 指的是只用于检查对象的这一行为。而反射既可以检查对象， 又可以修改对象。</p><p>python中自省的方法主要有以下几个：</p><ul><li>hasattr</li><li>getattr</li><li>setattr(需确认是否属于反射的范畴)</li><li>delattr</li><li>dir</li><li>isinstance</li><li>type</li><li>callable</li><li>inspect 库提供的方法</li></ul><h3 id="1-5-Python-中有哪些语法糖？有哪些常用的语法糖？"><a href="#1-5-Python-中有哪些语法糖？有哪些常用的语法糖？" class="headerlink" title="1.5 Python 中有哪些语法糖？有哪些常用的语法糖？"></a>1.5 Python 中有哪些语法糖？有哪些常用的语法糖？</h3><blockquote><p>在计算机科学中， 语法糖是指编程语言中可以更容易表达一个操作的语法， 它可以使程序员更加容易去使用这门语言： 操作可以变得更加清晰、方便， 或者更加符合程序员的编程习惯。</p></blockquote><p>python提供的语法糖有 索引、运算符、列表推导式、生成器推导式等等。</p><h3 id="1-6-Python3-相比-python2-有哪些重要的变化？具体有什么影响？"><a href="#1-6-Python3-相比-python2-有哪些重要的变化？具体有什么影响？" class="headerlink" title="1.6 Python3 相比 python2 有哪些重要的变化？具体有什么影响？"></a>1.6 Python3 相比 python2 有哪些重要的变化？具体有什么影响？</h3><ol><li>较重大的改变：<ol><li>print 从语句变成函数</li><li>编码问题， 3.x 默认使用 unicode， 取消了原来的 unicode 对象， str对象就相当于原来的unicode， 而原来的 str 在 3.x 中是bytes。</li><li>除法变化， 3.x 的除法返回浮点数</li><li>增加了类型注解（type hint）的支持， 帮助ide实现类型检查（也只是作为提醒而已）</li><li>优化super()方法， 方便直接调用父类函数</li><li>高级解包操作： a, b, *res = range(10)</li><li>增加 keyword only arguments 限定关键字参数</li><li>chained exception, python3 中重新抛出异常不会丢失堆栈信息</li></ol></li><li>新增特性：<ol><li>yield from 链接子生成器</li><li>asynico内置库， async/await 原生协程支持异步编程</li><li>新的内置库 enum， mock， asyncio， ipaddress， concurrent.future 等</li><li>生成的 pyc 文件统一放到 __pycache__</li><li>性能优化等</li></ol></li></ol><h3 id="1-7-如何将-Python2-的代码迁移到-Python3？"><a href="#1-7-如何将-Python2-的代码迁移到-Python3？" class="headerlink" title="1.7 如何将 Python2 的代码迁移到 Python3？"></a>1.7 如何将 Python2 的代码迁移到 Python3？</h3><h3 id="1-8-为什么说函数是一等公民？"><a href="#1-8-为什么说函数是一等公民？" class="headerlink" title="1.8 为什么说函数是一等公民？"></a>1.8 为什么说函数是一等公民？</h3><p>一等对象满足以下条件：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><h3 id="1-9-函数和方法的区别？"><a href="#1-9-函数和方法的区别？" class="headerlink" title="1.9 函数和方法的区别？"></a>1.9 函数和方法的区别？</h3><p>函数本质上是 FunctionObject， 而方法是 PyMethodObject。从声明的位置看，函数的命名空间是在模块上， 而方法的命名空间是实例。从实现的协议接口看， 函数相较方法拥有以下几个属性：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>__annotations__</td><td>dict</td><td>参数和返回值的注解</td></tr><tr><td>__call__</td><td>method-wrapper</td><td>实现 () 运算符；即可调用对象协议</td></tr><tr><td>__closure__</td><td>tuple</td><td>函数闭包， 即自由变量的绑定</td></tr><tr><td>__code__</td><td>code</td><td>编译成字节码的函数元数据和函数定义体</td></tr><tr><td>__defaults__</td><td>tuple</td><td>形式参数的默认值</td></tr><tr><td>__get__</td><td>method-wrapper</td><td>实现只读描述符协议</td></tr><tr><td>__globals__</td><td>dict</td><td>函数所在模块中的全局变量</td></tr><tr><td>__kwdefaults__</td><td>dict</td><td>仅限关键字形式参数的默认值</td></tr><tr><td>__name__</td><td>str</td><td>函数名称</td></tr></tbody></table><p>实例方法会在实例初始化的时候被绑定到实例对象上， 这个方法本质上是method对象， 但事实上解释器生成了方法所对应的function对象， 挂在 __func__这个命名空间上。而方法声明其实是类命名空间下的 function 对象。</p><h3 id="1-10-函数的传参过程是怎么样的？实参跟形参有什么区别？"><a href="#1-10-函数的传参过程是怎么样的？实参跟形参有什么区别？" class="headerlink" title="1.10 函数的传参过程是怎么样的？实参跟形参有什么区别？"></a>1.10 函数的传参过程是怎么样的？实参跟形参有什么区别？</h3><blockquote><p>参考资料：</p><p>《python学习手册》- 18章 - 参数</p></blockquote><p>python 的传参并不是引用传递， 也不是值传递， 而是传递“指针”。python 的参数传递是通过自动将对象赋值给本地变量名来实现的， 也就是说， 传参对对象创建了一个新的引用， 而在 Cython中， 引用是以指针的形式进行传递的。这也意味着传参过程中， 并没有对对象进行拷贝。</p><p>在函数运行时， 形参是一个新的、本地的变量名，这个变量名实在函数的本地作用域内的。在函数调用时， 形参跟实参都引用同一个对象。</p><h3 id="1-11-参数类型有哪些？"><a href="#1-11-参数类型有哪些？" class="headerlink" title="1.11 参数类型有哪些？"></a>1.11 参数类型有哪些？</h3><ul><li>位置参数</li><li>关键字参数</li><li>默认参数</li><li>可变位置参数</li><li>可变关键字参数</li><li>仅限关键字参数</li></ul><h3 id="1-12-传参时有哪些要注意的问题？"><a href="#1-12-传参时有哪些要注意的问题？" class="headerlink" title="1.12 传参时有哪些要注意的问题？"></a>1.12 传参时有哪些要注意的问题？</h3><ol><li>函数接收可变参数时， 函数中要谨慎对可变参数的修改；</li><li>参数默认值如果为可变参数的， 不要在形参处做初始化，应该使用None作为默认参数， 然后在函数内部作判断和初始化。</li></ol><h3 id="1-13-python中有哪些可变对象？哪些不可变对象？"><a href="#1-13-python中有哪些可变对象？哪些不可变对象？" class="headerlink" title="1.13 python中有哪些可变对象？哪些不可变对象？"></a>1.13 python中有哪些可变对象？哪些不可变对象？</h3><p>可变对象： list, bytearray, array.array, collections.deque, memoryview,  dict, set</p><p>不可变对象： tuple, str, bytes,  bool, frozenset, 数值类型</p><p>元组是相对不可变的对象， 元组存储的是对象的引用， 当元组中的存在可变对象的引用时， 引用不可变， 但是引用的对象时可变的。</p><h3 id="1-14-生成器和迭代器有什么区别？"><a href="#1-14-生成器和迭代器有什么区别？" class="headerlink" title="1.14 生成器和迭代器有什么区别？"></a>1.14 生成器和迭代器有什么区别？</h3><p>迭代器是生成器的一种。 迭代器与可迭代对象又是不同的对象类型.</p><!-- TODO: 从接口协议的角度说明迭代器需要实现哪些协议接口，可迭代对象需要实现哪些协议接口， 生成器需要实现哪些接口。三种对象的实现方式。 --><h3 id="1-15-如何实现协程？"><a href="#1-15-如何实现协程？" class="headerlink" title="1.15 如何实现协程？"></a>1.15 如何实现协程？</h3><!-- TODO: 说明协程的实现方式 --><h3 id="1-16-python中如何进行异常处理？如何自定义一个异常类？"><a href="#1-16-python中如何进行异常处理？如何自定义一个异常类？" class="headerlink" title="1.16 python中如何进行异常处理？如何自定义一个异常类？"></a>1.16 python中如何进行异常处理？如何自定义一个异常类？</h3><p>python使用 try … except … finally … 捕获异常。 自定义异常类通常继承自 Exception 类，最简单的继承方式就是 声明一个类继承自 Exception， 不需要新增属性和方法。</p><h3 id="1-17-什么时候需要捕获异常？"><a href="#1-17-什么时候需要捕获异常？" class="headerlink" title="1.17 什么时候需要捕获异常？"></a>1.17 什么时候需要捕获异常？</h3><!-- TODO: 总结下需要捕获异常的场景 --><h3 id="1-18-什么是单元测试？python中如何进行单元测试？"><a href="#1-18-什么是单元测试？python中如何进行单元测试？" class="headerlink" title="1.18 什么是单元测试？python中如何进行单元测试？"></a>1.18 什么是单元测试？python中如何进行单元测试？</h3><h3 id="1-19-什么是浅拷贝？什么是深拷贝？如何实现深拷贝？"><a href="#1-19-什么是浅拷贝？什么是深拷贝？如何实现深拷贝？" class="headerlink" title="1.19 什么是浅拷贝？什么是深拷贝？如何实现深拷贝？"></a>1.19 什么是浅拷贝？什么是深拷贝？如何实现深拷贝？</h3><!-- TODO: 网上的文章对深拷贝的实现都是单独讨论对列表和字典进行深拷贝， 但如果把深拷贝的范围扩展到自定义的对象呢？python的 deepcopy 考虑了很多东西， 而且必要实现一些接口协议才能够进行深拷贝。 --><h3 id="1-20-python如何管理依赖？"><a href="#1-20-python如何管理依赖？" class="headerlink" title="1.20 python如何管理依赖？"></a>1.20 python如何管理依赖？</h3><p>依赖管理历史：</p><h3 id="1-21-如何分析python代码的性能？如何优化python的性能？"><a href="#1-21-如何分析python代码的性能？如何优化python的性能？" class="headerlink" title="1.21 如何分析python代码的性能？如何优化python的性能？"></a>1.21 如何分析python代码的性能？如何优化python的性能？</h3><h3 id="1-22-什么是GIL？如何规避GIL的影响？"><a href="#1-22-什么是GIL？如何规避GIL的影响？" class="headerlink" title="1.22 什么是GIL？如何规避GIL的影响？"></a>1.22 什么是GIL？如何规避GIL的影响？</h3><p>GIL是仅在cython解释器版本才存在的， 通过GIL， python解释器保证多线程情况下， 同一时间， 内核只执行一条语句。规避手段见 python cookbook。</p><p>GIL存在的愿意是因为解释器的 C 语言实现部分在完全并行执行时并不是线程安全的。因此在设计上， 解释器被一个全局解释器锁保护着， 它确保任何时候都只有一个 Python 线程执行。 GIL最大的问题就是 Python 的多线程程序并不能利用多核 CPU 的优势（比如一个使用了多线程的计算密集型程序只会在一个单CPU上面运行）， 所以 GIL 对于 IO 密集型的程序是没有多大影响的。解决 GIL 缺陷的途径有两种： 1. 使用进程池；2. 使用 C 扩展编程技术，使用 ctypes 调用 C 时会自动释放GIL。</p><h3 id="1-23-python有哪些内置数据结构？"><a href="#1-23-python有哪些内置数据结构？" class="headerlink" title="1.23 python有哪些内置数据结构？"></a>1.23 python有哪些内置数据结构？</h3><!-- TODO: 抄一下 --><h3 id="1-24-列表和元组有什么区别？"><a href="#1-24-列表和元组有什么区别？" class="headerlink" title="1.24 列表和元组有什么区别？"></a>1.24 列表和元组有什么区别？</h3><!-- 数据结构的角度（数据存储和操作）、使用场景的角度 --><h3 id="1-25-python的字典是如何实现的？"><a href="#1-25-python的字典是如何实现的？" class="headerlink" title="1.25 python的字典是如何实现的？"></a>1.25 python的字典是如何实现的？</h3><blockquote><p>参考资料：</p><p>《流畅的python》-3章</p></blockquote><p>python字典的底层实现是散列表。</p><h3 id="1-26-什么是随机访问？"><a href="#1-26-什么是随机访问？" class="headerlink" title="1.26 什么是随机访问？"></a>1.26 什么是随机访问？</h3><p>数组中的元素存储在一段连续内存中， 访问数组中任意元素都可以通过下标计算直接得到元素的内存地址， 访问耗时与元素的数组中所处的位置无关。与之相对的是链表的顺序访问。</p><h3 id="1-27-内置数据结构常用操作的时间复杂度是多少？"><a href="#1-27-内置数据结构常用操作的时间复杂度是多少？" class="headerlink" title="1.27 内置数据结构常用操作的时间复杂度是多少？"></a>1.27 内置数据结构常用操作的时间复杂度是多少？</h3><!-- TODO: 列个表--><h3 id="1-28-什么是闭包？"><a href="#1-28-什么是闭包？" class="headerlink" title="1.28 什么是闭包？"></a>1.28 什么是闭包？</h3><p>在一个内部函数里， 对在外部作用域（不在全局作用域）的变量进行引用， 那么这个内部函数就是闭包（closure）。在闭包中操作引用了不可变对象的自由变量时， 如果涉及到对自由变量的重新赋值， 在python中， 要在闭包内 用 nonlocal 关键字先声明这个自由变量， 否则赋值时， 该变量会被视为本地变量；而在python2中， 需要将该对象放入可变对象中。</p><h3 id="1-29-实现一个装饰器"><a href="#1-29-实现一个装饰器" class="headerlink" title="1.29 实现一个装饰器"></a>1.29 实现一个装饰器</h3><h3 id="1-30-实现一个装饰器工厂"><a href="#1-30-实现一个装饰器工厂" class="headerlink" title="1.30 实现一个装饰器工厂"></a>1.30 实现一个装饰器工厂</h3><h3 id="1-31-装饰器通常用来实现什么功能？"><a href="#1-31-装饰器通常用来实现什么功能？" class="headerlink" title="1.31 装饰器通常用来实现什么功能？"></a>1.31 装饰器通常用来实现什么功能？</h3><h3 id="1-32-什么叫高阶函数？python中有哪些高阶函数？"><a href="#1-32-什么叫高阶函数？python中有哪些高阶函数？" class="headerlink" title="1.32 什么叫高阶函数？python中有哪些高阶函数？"></a>1.32 什么叫高阶函数？python中有哪些高阶函数？</h3><!-- TODO: 其实实践了FP范式 --><h3 id="1-33-什么是面向对象？"><a href="#1-33-什么是面向对象？" class="headerlink" title="1.33 什么是面向对象？"></a>1.33 什么是面向对象？</h3><!-- TODO: 这种简单的问题就是比较烦人， 不知道从那个点切入去讲， 查一查 --><h3 id="1-34-面向对象有哪些特征？"><a href="#1-34-面向对象有哪些特征？" class="headerlink" title="1.34 面向对象有哪些特征？"></a>1.34 面向对象有哪些特征？</h3><!-- TODO: 封装、继承、多态 --><h3 id="1-35-什么是元编程？有哪些案例？"><a href="#1-35-什么是元编程？有哪些案例？" class="headerlink" title="1.35 什么是元编程？有哪些案例？"></a>1.35 什么是元编程？有哪些案例？</h3><!-- TODO: 流畅的python --><h3 id="1-36-什么是类元编程？"><a href="#1-36-什么是类元编程？" class="headerlink" title="1.36 什么是类元编程？"></a>1.36 什么是类元编程？</h3><!-- TODO: 流畅的python --><h3 id="1-37-类是谁的对象？type是谁的对象？"><a href="#1-37-类是谁的对象？type是谁的对象？" class="headerlink" title="1.37 类是谁的对象？type是谁的对象？"></a>1.37 类是谁的对象？type是谁的对象？</h3><!-- TODO: python 继承树，类是type的对象， type是自己的对象(实际上 type 也继承了object， 所以 python中， 一切皆'对象' 也有这个设计层面的含义) --><h3 id="1-38-python的垃圾回收机制是如何工作的？"><a href="#1-38-python的垃圾回收机制是如何工作的？" class="headerlink" title="1.38 python的垃圾回收机制是如何工作的？"></a>1.38 python的垃圾回收机制是如何工作的？</h3><p>python的GC机制是以引用计数为主， 标志清除和分代回收为辅的策略。</p><p>python中的每一个对象都维护一个引用计数， 当该对象的引用数为 0 时， 该对象立即被回收。可以通过以下方式获取对象的引用次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Test()</span><br><span class="line">print(sys.getrefcount(a))  <span class="comment"># 函数调用时， 将对象赋值给了形参， 会增加一次引用</span></span><br></pre></td></tr></table></figure><p>引用计数可以处理大部分对象的回收， 但是对于循环引用的对象， 它们的计数引用总会大于0。</p><p>为了解决对象循环引用的问题， python中引入了标记清除和分代回收两种机制。</p><p>标记清除算法时一种基于追踪回收技术实现的GC算法， 这个算法分 <strong>两个</strong> 阶段， 第一个阶段是标记， GC会把所有的活动对象打上标记， 第二阶段是把那些没有标记的对象 <strong>非活动对象</strong> 进行回收。对象之间通过引用连在一起， 构成一个有向图， 对象构成这个图的节点， 引用构成有向边。从根节点（全局变量、调用栈、寄存器）出发， 沿着有向边遍历对象， 可达的对象标记为活动对象， 不可达的对象就是要被清除的非活动对象。</p><p>为了标记活动对象， 解释器必须顺序扫描整个堆内存， 哪怕只剩下小部分活动对象也要扫描所有对象，而且什么时候扫描并不是用户控制的。</p><p>为了解决这个缺陷， 又引入了分代回收。分代回收是一种空间换事件的操作方式。python将内存根据对象的存活时间划分为不同的集合， 每个集合称为一个代， python将内存分为3代， 对应3个链表， 他们的垃圾收集频率与对象的存活时间增大而减小。新创建的对象都被分配在年轻代， 年轻代链表填满时， GC就会被触发， 释放可回收的， 不可回收的移到中年代去；中年代GC的触发以此类比。</p><h3 id="1-39-什么是工厂模式？核心思想是什么？什么场景下可以使用工厂模式？"><a href="#1-39-什么是工厂模式？核心思想是什么？什么场景下可以使用工厂模式？" class="headerlink" title="1.39 什么是工厂模式？核心思想是什么？什么场景下可以使用工厂模式？"></a>1.39 什么是工厂模式？核心思想是什么？什么场景下可以使用工厂模式？</h3><!-- TODO: 重构与模式一书 --><h3 id="1-40-什么是构造模式？"><a href="#1-40-什么是构造模式？" class="headerlink" title="1.40 什么是构造模式？"></a>1.40 什么是构造模式？</h3><h3 id="1-41-什么是原型模式？"><a href="#1-41-什么是原型模式？" class="headerlink" title="1.41 什么是原型模式？"></a>1.41 什么是原型模式？</h3><h3 id="1-42-什么是单例模式？"><a href="#1-42-什么是单例模式？" class="headerlink" title="1.42 什么是单例模式？"></a>1.42 什么是单例模式？</h3><h3 id="1-43-什么是装饰器模式？"><a href="#1-43-什么是装饰器模式？" class="headerlink" title="1.43 什么是装饰器模式？"></a>1.43 什么是装饰器模式？</h3><h3 id="1-44-什么是代理模式？"><a href="#1-44-什么是代理模式？" class="headerlink" title="1.44 什么是代理模式？"></a>1.44 什么是代理模式？</h3><h3 id="1-45-什么是适配器模式？"><a href="#1-45-什么是适配器模式？" class="headerlink" title="1.45 什么是适配器模式？"></a>1.45 什么是适配器模式？</h3><h3 id="1-46-什么是外观模式？"><a href="#1-46-什么是外观模式？" class="headerlink" title="1.46 什么是外观模式？"></a>1.46 什么是外观模式？</h3><h3 id="1-47-什么是享元模式？"><a href="#1-47-什么是享元模式？" class="headerlink" title="1.47 什么是享元模式？"></a>1.47 什么是享元模式？</h3><h3 id="1-48-什么是MVC模式？"><a href="#1-48-什么是MVC模式？" class="headerlink" title="1.48 什么是MVC模式？"></a>1.48 什么是MVC模式？</h3><h3 id="1-49-什么是惰性计算模式"><a href="#1-49-什么是惰性计算模式" class="headerlink" title="1.49 什么是惰性计算模式"></a>1.49 什么是惰性计算模式</h3><h3 id="1-50-什么是迭代器模式？"><a href="#1-50-什么是迭代器模式？" class="headerlink" title="1.50 什么是迭代器模式？"></a>1.50 什么是迭代器模式？</h3><h3 id="1-51-什么是观察者模式？"><a href="#1-51-什么是观察者模式？" class="headerlink" title="1.51 什么是观察者模式？"></a>1.51 什么是观察者模式？</h3><h3 id="1-52-什么是策略模式？"><a href="#1-52-什么是策略模式？" class="headerlink" title="1.52 什么是策略模式？"></a>1.52 什么是策略模式？</h3><h3 id="1-53-简述TCP编程的原理"><a href="#1-53-简述TCP编程的原理" class="headerlink" title="1.53 简述TCP编程的原理"></a>1.53 简述TCP编程的原理</h3><!-- TODO: 重点准备 --><h3 id="1-54-如何使用-socket-编程发送-HTTP-请求？"><a href="#1-54-如何使用-socket-编程发送-HTTP-请求？" class="headerlink" title="1.54 如何使用 socket 编程发送 HTTP 请求？"></a>1.54 如何使用 socket 编程发送 HTTP 请求？</h3><!-- TODO: 重点准备， 系统层面的 socket api + HTTP 协议结构 --><h3 id="1-55-什么是阻塞socket？什么是非阻塞socket？"><a href="#1-55-什么是阻塞socket？什么是非阻塞socket？" class="headerlink" title="1.55 什么是阻塞socket？什么是非阻塞socket？"></a>1.55 什么是阻塞socket？什么是非阻塞socket？</h3><!-- TODO: 重点准备， 这个最终可以深入到 IO 模型， 底层就是对应系统socket 的IO机制 --><h3 id="1-56-简述-IO-多路复用机制"><a href="#1-56-简述-IO-多路复用机制" class="headerlink" title="1.56 简述 IO 多路复用机制"></a>1.56 简述 IO 多路复用机制</h3><!-- TODO: 重点准备 --><h3 id="1-57-五种IO模型分别是什么？"><a href="#1-57-五种IO模型分别是什么？" class="headerlink" title="1.57 五种IO模型分别是什么？"></a>1.57 五种IO模型分别是什么？</h3><!-- TODO: 重点准备 --><h3 id="1-58-如何提升服务器的并发能力？"><a href="#1-58-如何提升服务器的并发能力？" class="headerlink" title="1.58 如何提升服务器的并发能力？"></a>1.58 如何提升服务器的并发能力？</h3><!-- TODO: 重点准备 --><h3 id="1-59-什么是-IO-多路服务用？"><a href="#1-59-什么是-IO-多路服务用？" class="headerlink" title="1.59 什么是 IO 多路服务用？"></a>1.59 什么是 IO 多路服务用？</h3><!-- TODO: 重点准备 --><h3 id="1-60-select-poll-epoll的区别"><a href="#1-60-select-poll-epoll的区别" class="headerlink" title="1.60 select/poll/epoll的区别"></a>1.60 select/poll/epoll的区别</h3><!-- TODO: 重点准备 --><h3 id="1-61-python中如何实现-IO-多路复用"><a href="#1-61-python中如何实现-IO-多路复用" class="headerlink" title="1.61 python中如何实现 IO 多路复用"></a>1.61 python中如何实现 IO 多路复用</h3><!-- TODO: 重点准备 --><h3 id="1-62-python常用的并发网络库"><a href="#1-62-python常用的并发网络库" class="headerlink" title="1.62 python常用的并发网络库"></a>1.62 python常用的并发网络库</h3><!-- TODO: 重点准备 --><h3 id="1-63-使用-tornado-构建微服务，-实现-restful-接口"><a href="#1-63-使用-tornado-构建微服务，-实现-restful-接口" class="headerlink" title="1.63 使用 tornado 构建微服务， 实现 restful 接口"></a>1.63 使用 tornado 构建微服务， 实现 restful 接口</h3><!-- TODO: 重点准备 --><h3 id="1-64-gevent-的并发实现原理"><a href="#1-64-gevent-的并发实现原理" class="headerlink" title="1.64 gevent 的并发实现原理"></a>1.64 gevent 的并发实现原理</h3><!-- TODO: 重点准备 --><h3 id="1-65-什么是-WSGI？-为什么需要-WSGI？"><a href="#1-65-什么是-WSGI？-为什么需要-WSGI？" class="headerlink" title="1.65 什么是 WSGI？ 为什么需要 WSGI？"></a>1.65 什么是 WSGI？ 为什么需要 WSGI？</h3><!-- TODO: 重点准备 --><h3 id="1-66-Django、Flask-和-Tornado-之间的异同？"><a href="#1-66-Django、Flask-和-Tornado-之间的异同？" class="headerlink" title="1.66 Django、Flask 和 Tornado 之间的异同？"></a>1.66 Django、Flask 和 Tornado 之间的异同？</h3><!-- TODO: 重点准备 --><h3 id="1-67-什么是-MVC？"><a href="#1-67-什么是-MVC？" class="headerlink" title="1.67 什么是 MVC？"></a>1.67 什么是 MVC？</h3><!-- TODO: 重点准备 --><h3 id="1-68-为什么要使用-ORM"><a href="#1-68-为什么要使用-ORM" class="headerlink" title="1.68 为什么要使用 ORM"></a>1.68 为什么要使用 ORM</h3><!-- TODO: 重点准备 --><h3 id="1-69-常见的-web-安全问题有哪些？"><a href="#1-69-常见的-web-安全问题有哪些？" class="headerlink" title="1.69 常见的 web 安全问题有哪些？"></a>1.69 常见的 web 安全问题有哪些？</h3><!-- TODO: 重点准备 --><h3 id="1-70-sql注入的原理是什么？如何防范？"><a href="#1-70-sql注入的原理是什么？如何防范？" class="headerlink" title="1.70 sql注入的原理是什么？如何防范？"></a>1.70 sql注入的原理是什么？如何防范？</h3><!-- TODO: 重点准备 --><h3 id="1-71-XSS攻击的原理是什么？如何防范？"><a href="#1-71-XSS攻击的原理是什么？如何防范？" class="headerlink" title="1.71 XSS攻击的原理是什么？如何防范？"></a>1.71 XSS攻击的原理是什么？如何防范？</h3><!-- TODO: 重点准备 --><h3 id="1-72-CSRF的作用是什么？"><a href="#1-72-CSRF的作用是什么？" class="headerlink" title="1.72 CSRF的作用是什么？"></a>1.72 CSRF的作用是什么？</h3><!-- TODO: 重点准备 --><h3 id="1-73-什么是前后端分离？有哪些优点？"><a href="#1-73-什么是前后端分离？有哪些优点？" class="headerlink" title="1.73 什么是前后端分离？有哪些优点？"></a>1.73 什么是前后端分离？有哪些优点？</h3><!-- TODO: 重点准备 --><h3 id="1-74-什么是-restful？"><a href="#1-74-什么是-restful？" class="headerlink" title="1.74 什么是 restful？"></a>1.74 什么是 restful？</h3><!-- TODO: 重点准备 --><h3 id="1-75-restful的准则是什么？"><a href="#1-75-restful的准则是什么？" class="headerlink" title="1.75 restful的准则是什么？"></a>1.75 restful的准则是什么？</h3><!-- TODO: 重点准备 --><h3 id="1-76-什么是restful-api？"><a href="#1-76-什么是restful-api？" class="headerlink" title="1.76 什么是restful api？"></a>1.76 什么是restful api？</h3><!-- TODO: 重点准备 --><h3 id="1-77-如何设计-restful-api？"><a href="#1-77-如何设计-restful-api？" class="headerlink" title="1.77 如何设计 restful api？"></a>1.77 如何设计 restful api？</h3><!-- TODO: 重点准备 --><h3 id="1-78-什么是-HTTPS？"><a href="#1-78-什么是-HTTPS？" class="headerlink" title="1.78 什么是 HTTPS？"></a>1.78 什么是 HTTPS？</h3><!-- TODO: 重点准备 --><h2 id="Part-2-操作系统相关问题"><a href="#Part-2-操作系统相关问题" class="headerlink" title="Part 2: 操作系统相关问题"></a>Part 2: 操作系统相关问题</h2><p><strong>本节内容主要与操作系统有关， 但是有部分问题也可以纳入编程语言的范畴， 比如进程、线程相关的问题。操作系统相关问题主要从两个层面准备，一是与上层应用开发相关的内容， 如内存管理机制；另一个是常用的命令。</strong></p><h3 id="2-1-进程、线程以及协程间的区别"><a href="#2-1-进程、线程以及协程间的区别" class="headerlink" title="2.1 进程、线程以及协程间的区别"></a>2.1 进程、线程以及协程间的区别</h3><p>进程： 资源分配的单位。分配了哪些资源呢？</p><p>线程： CPU调度的单位。</p><p>协程并不是系统层面的， 而是由程序控制的一种程序结构。</p><p>TODO: 资源共享和竞争的问题。  从语言的角度看， 进程、线程和协程的区别。</p><h3 id="2-2-线程间通信的方式"><a href="#2-2-线程间通信的方式" class="headerlink" title="2.2 线程间通信的方式"></a>2.2 线程间通信的方式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 延伸问题：</span></span><br><span class="line">python中， queue.Queue 为什么是线程安全的？</span><br><span class="line"></span><br><span class="line"><span class="section">#### 延伸思考：</span></span><br><span class="line">使用基于消息队列模式python多线程编程是多线程编程的一种最佳模式。</span><br></pre></td></tr></table></figure><p>线程共享同一份全局内存区域*， 所以线程之间可以方便， 快速地共享信息， 只需要将数据复制到共享变量（全局）中即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">共享的全局内存区域包括：</span><br><span class="line">初始化数据段， 未初始化数据段 以及 堆内存段</span><br><span class="line"></span><br><span class="line">相关知识点：</span><br><span class="line">进程的地址空间</span><br></pre></td></tr></table></figure><p>如果变量是只读的， 多个线程同时读取该变量不会有一致性问题， 但是， 当线程对变量有修改操作时， 就会有一致性的隐患， 所以要通过一些机制将变量的状态对所有线程同步， 确保线程不会访问到无效的变量内容。</p><p>线程间同步的方式主要有以下几种：</p><ul><li>互斥锁</li></ul><!-- 目前 python 编程时没怎么遇到会造成死锁的情况？因为使用到的多线程通常是执行相同的任务， 而且没有多个资源多个锁的情况 --><blockquote><p>互斥量的死锁:<br>一个线程需要访问两个或者更多不同的共享资源，而每个资源又有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发生死锁。死锁就是指多个线程/进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进。<br>死锁的处理策略：<br>1、预防死锁：破坏死锁产生的四个条件：互斥条件、不剥夺条件、请求和保持条件以及循环等待条件。<br>2、避免死锁：在每次进行资源分配前，应该计算此次分配资源的安全性，如果此次资源分配不会导致系统进入不安全状态，那么将资源分配给进程，否则等待。算法：银行家算法。<br>3、检测死锁：检测到死锁后通过资源剥夺、撤销进程、进程回退等方法解除死锁。<br>————————————————<br>版权声明：本文为CSDN博主「yexz」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/a987073381/java/article/details/52029070" target="_blank" rel="noopener">https://blog.csdn.net/a987073381/java/article/details/52029070</a></p></blockquote><ul><li>读写锁</li></ul><blockquote><p> 读写锁有三种状态：读模式下加锁， 写模式下加锁， 不加锁状态。一次只有一个线程可以占有写模式的读写锁， 但是多个线程可以同时占有读模式的读写锁。当读写锁是写加锁状态是， 在这个锁被解锁之前， 所有试图对这个锁加锁的线程都会被阻塞， 当读写锁在读加锁状态是， 所有试图以读模式它进行加锁的线程都可以得到访问权， 但是希望以写模式对锁进行加锁的线程都会阻塞， 直到所有的线程释放他们的锁为止。</p></blockquote><ul><li>条件变量</li></ul><blockquote><p>互斥量用于上锁， 条件变量则用于等待， 并且条件变量总是需要与互斥量一起使用， 运行线程以无竞争的方式等待特定的条件发生。</p><p>条件变量本身是由互斥量保护的， 线程在改变条件之前必须先锁住互斥量。其他线程在获得互斥量之前不会觉察到这种变化， 因为互斥量必须在锁定之后才能计算条件。</p></blockquote><ul><li>信号量</li></ul><blockquote><p>线程的信号量和进程的信号量类似， 使用线程的信号量可以高效地完成基于线程的资源计数。信号量实际上是一个非负的整数计数器， 用来实现对公共资源的控制。在公共资源增加的时候， 信号量就增加， 公共资源减少的时候， 信号量就减少；只用当信号量的值大于0的时候， 才能访问信号量所代表的公共资源。</p></blockquote><ul><li>自旋锁</li></ul><blockquote><p>自旋锁与互斥量类似， 但它不是通过休眠使进程阻塞， 而是在获取锁之前一直忙于等（自旋）阻塞状态。自旋锁可以用于以下情况：锁被持有的时间短， 而且线程并不希望在重新调度上花费太多的成本。</p></blockquote><ul><li>屏障</li></ul><blockquote><p>屏障是指用户可以协调多个线程并行工作的同步机制， 屏障允许每个线程等待， 直到所有的合作线程都达到某一点， 然后从该点继续执行。</p></blockquote><!-- TODO: python中的线程同步方式, python中的线程同步方式跟java中是不同的， 所以线程同步这块的通用知识还是要去看操作系统层面的 --><h3 id="2-3-进程间通信的方式"><a href="#2-3-进程间通信的方式" class="headerlink" title="2.3 进程间通信的方式"></a>2.3 进程间通信的方式</h3><h3 id="2-4-Linux内存管理机制"><a href="#2-4-Linux内存管理机制" class="headerlink" title="2.4 Linux内存管理机制"></a>2.4 Linux内存管理机制</h3><h3 id="2-5-Linux常用命令"><a href="#2-5-Linux常用命令" class="headerlink" title="2.5 Linux常用命令"></a>2.5 Linux常用命令</h3><h2 id="Part-3-数据库相关"><a href="#Part-3-数据库相关" class="headerlink" title="Part 3: 数据库相关"></a>Part 3: 数据库相关</h2><p><strong>数据库部分的问题主要准备 mysql 相关的问题以及缓存数据库相关的问题， 在此基础上如果有余力， 可以增加 elasticsearch 相关的问题。</strong></p><h3 id="3-1-mysql-事务原理、特性以及事务的并发控制"><a href="#3-1-mysql-事务原理、特性以及事务的并发控制" class="headerlink" title="3.1 mysql 事务原理、特性以及事务的并发控制"></a>3.1 mysql 事务原理、特性以及事务的并发控制</h3><h3 id="3-2-事务缺乏并发控制会产生哪些异常"><a href="#3-2-事务缺乏并发控制会产生哪些异常" class="headerlink" title="3.2 事务缺乏并发控制会产生哪些异常"></a>3.2 事务缺乏并发控制会产生哪些异常</h3><h3 id="3-3-事务的四种隔离级别"><a href="#3-3-事务的四种隔离级别" class="headerlink" title="3.3 事务的四种隔离级别"></a>3.3 事务的四种隔离级别</h3><h3 id="3-4-如何解决高并发场景下的插入重复"><a href="#3-4-如何解决高并发场景下的插入重复" class="headerlink" title="3.4 如何解决高并发场景下的插入重复"></a>3.4 如何解决高并发场景下的插入重复</h3><h3 id="3-5-什么是悲观锁"><a href="#3-5-什么是悲观锁" class="headerlink" title="3.5 什么是悲观锁"></a>3.5 什么是悲观锁</h3><h3 id="3-6-什么是乐观锁"><a href="#3-6-什么是乐观锁" class="headerlink" title="3.6 什么是乐观锁"></a>3.6 什么是乐观锁</h3><h3 id="3-7-乐观锁和悲观锁的选择"><a href="#3-7-乐观锁和悲观锁的选择" class="headerlink" title="3.7 乐观锁和悲观锁的选择"></a>3.7 乐观锁和悲观锁的选择</h3><h3 id="3-8-mysql-常用数据类型"><a href="#3-8-mysql-常用数据类型" class="headerlink" title="3.8 mysql 常用数据类型"></a>3.8 mysql 常用数据类型</h3><h3 id="3-9-mysql数据库引擎"><a href="#3-9-mysql数据库引擎" class="headerlink" title="3.9 mysql数据库引擎"></a>3.9 mysql数据库引擎</h3><h3 id="3-10-什么是索引"><a href="#3-10-什么是索引" class="headerlink" title="3.10 什么是索引"></a>3.10 什么是索引</h3><h3 id="3-11-mysql索引的数据结构"><a href="#3-11-mysql索引的数据结构" class="headerlink" title="3.11 mysql索引的数据结构"></a>3.11 mysql索引的数据结构</h3><h3 id="3-12-mysql的索引类型"><a href="#3-12-mysql的索引类型" class="headerlink" title="3.12 mysql的索引类型"></a>3.12 mysql的索引类型</h3><h3 id="3-13-什么时候创建索引？有什么需要注意的？"><a href="#3-13-什么时候创建索引？有什么需要注意的？" class="headerlink" title="3.13 什么时候创建索引？有什么需要注意的？"></a>3.13 什么时候创建索引？有什么需要注意的？</h3><h3 id="3-14-索引什么时候失效"><a href="#3-14-索引什么时候失效" class="headerlink" title="3.14 索引什么时候失效"></a>3.14 索引什么时候失效</h3><h3 id="3-15-什么是聚集索引，-什么是非聚集索引"><a href="#3-15-什么是聚集索引，-什么是非聚集索引" class="headerlink" title="3.15 什么是聚集索引， 什么是非聚集索引"></a>3.15 什么是聚集索引， 什么是非聚集索引</h3><h3 id="3-16-如何排查慢查询"><a href="#3-16-如何排查慢查询" class="headerlink" title="3.16 如何排查慢查询"></a>3.16 如何排查慢查询</h3><h3 id="3-17-什么是内连接、外连接和全连接"><a href="#3-17-什么是内连接、外连接和全连接" class="headerlink" title="3.17 什么是内连接、外连接和全连接"></a>3.17 什么是内连接、外连接和全连接</h3><h3 id="3-18-缓存的使用场景"><a href="#3-18-缓存的使用场景" class="headerlink" title="3.18 缓存的使用场景"></a>3.18 缓存的使用场景</h3><h3 id="3-19-redis-和-memcached-的主要区别"><a href="#3-19-redis-和-memcached-的主要区别" class="headerlink" title="3.19 redis  和 memcached 的主要区别"></a>3.19 redis  和 memcached 的主要区别</h3><h3 id="3-20-请简述-redis-常用数据类型和使用场景"><a href="#3-20-请简述-redis-常用数据类型和使用场景" class="headerlink" title="3.20 请简述 redis 常用数据类型和使用场景"></a>3.20 请简述 redis 常用数据类型和使用场景</h3><h3 id="3-21-redis-数据类型的内置实现"><a href="#3-21-redis-数据类型的内置实现" class="headerlink" title="3.21 redis 数据类型的内置实现"></a>3.21 redis 数据类型的内置实现</h3><h3 id="3-22-redis-有哪些持久化方式"><a href="#3-22-redis-有哪些持久化方式" class="headerlink" title="3.22 redis 有哪些持久化方式"></a>3.22 redis 有哪些持久化方式</h3><h3 id="3-23-什么是-redis-事务"><a href="#3-23-什么是-redis-事务" class="headerlink" title="3.23 什么是 redis 事务"></a>3.23 什么是 redis 事务</h3><h3 id="3-24-redis-如何实现分布式锁"><a href="#3-24-redis-如何实现分布式锁" class="headerlink" title="3.24 redis 如何实现分布式锁"></a>3.24 redis 如何实现分布式锁</h3><h3 id="3-25-使用缓存的模式"><a href="#3-25-使用缓存的模式" class="headerlink" title="3.25 使用缓存的模式"></a>3.25 使用缓存的模式</h3><h3 id="3-26-什么是缓存穿透"><a href="#3-26-什么是缓存穿透" class="headerlink" title="3.26 什么是缓存穿透"></a>3.26 什么是缓存穿透</h3><h3 id="3-27-什么是缓存击穿"><a href="#3-27-什么是缓存击穿" class="headerlink" title="3.27 什么是缓存击穿"></a>3.27 什么是缓存击穿</h3><h3 id="3-28-什么是缓存雪崩"><a href="#3-28-什么是缓存雪崩" class="headerlink" title="3.28 什么是缓存雪崩"></a>3.28 什么是缓存雪崩</h3><h3 id="3-29-为什么-mysql-数据库的主键使用自增的整数比较好，-使用uuid可以吗，-如果是分布式系统下怎么生成数据库的自增id"><a href="#3-29-为什么-mysql-数据库的主键使用自增的整数比较好，-使用uuid可以吗，-如果是分布式系统下怎么生成数据库的自增id" class="headerlink" title="3.29 为什么 mysql 数据库的主键使用自增的整数比较好， 使用uuid可以吗， 如果是分布式系统下怎么生成数据库的自增id"></a>3.29 为什么 mysql 数据库的主键使用自增的整数比较好， 使用uuid可以吗， 如果是分布式系统下怎么生成数据库的自增id</h3><h3 id="3-30-基于-redis-编写代码实现一个简单的分布式锁"><a href="#3-30-基于-redis-编写代码实现一个简单的分布式锁" class="headerlink" title="3.30 基于 redis 编写代码实现一个简单的分布式锁"></a>3.30 基于 redis 编写代码实现一个简单的分布式锁</h3><h2 id="Part-4-网络协议"><a href="#Part-4-网络协议" class="headerlink" title="Part 4: 网络协议"></a>Part 4: 网络协议</h2><h3 id="4-1-浏览器输入一个-URL-中间经历的过程"><a href="#4-1-浏览器输入一个-URL-中间经历的过程" class="headerlink" title="4.1 浏览器输入一个 URL 中间经历的过程"></a>4.1 浏览器输入一个 URL 中间经历的过程</h3><ol><li>DNS 解析地址</li><li>建立 TCP 连接</li><li>发送 HTTP 请求</li><li>接收响应、获取静态资源</li><li>关闭连接</li><li>渲染 HTML</li></ol><h3 id="4-2-网络的分层模型"><a href="#4-2-网络的分层模型" class="headerlink" title="4.2 网络的分层模型"></a>4.2 网络的分层模型</h3><!-- TODO: 重点准备， 实际开发过程中使用的是四层（五层）模型，但是对于理解网络结构而言，OSI七层模型划分更清晰 --><h3 id="4-3-TCP-的握手过程"><a href="#4-3-TCP-的握手过程" class="headerlink" title="4.3 TCP 的握手过程"></a>4.3 TCP 的握手过程</h3><!-- TODO: 重点准备 --><h3 id="4-4-TCP-的挥手过程"><a href="#4-4-TCP-的挥手过程" class="headerlink" title="4.4 TCP 的挥手过程"></a>4.4 TCP 的挥手过程</h3><!-- TODO: 重点准备 --><h3 id="4-5-TCP-跟-UDP-的差别"><a href="#4-5-TCP-跟-UDP-的差别" class="headerlink" title="4.5 TCP 跟 UDP 的差别"></a>4.5 TCP 跟 UDP 的差别</h3><!-- TODO: 重点准备 --><h3 id="4-6-HTTP-请求由哪些部分组成"><a href="#4-6-HTTP-请求由哪些部分组成" class="headerlink" title="4.6 HTTP 请求由哪些部分组成"></a>4.6 HTTP 请求由哪些部分组成</h3><h3 id="4-7-常见的-HTTP-响应状态码"><a href="#4-7-常见的-HTTP-响应状态码" class="headerlink" title="4.7 常见的 HTTP 响应状态码"></a>4.7 常见的 HTTP 响应状态码</h3><h3 id="4-8-什么是幂等方法，-哪些-HTTP-方法是幂等的"><a href="#4-8-什么是幂等方法，-哪些-HTTP-方法是幂等的" class="headerlink" title="4.8 什么是幂等方法， 哪些 HTTP 方法是幂等的"></a>4.8 什么是幂等方法， 哪些 HTTP 方法是幂等的</h3><h3 id="4-9-HTTP-的长链接"><a href="#4-9-HTTP-的长链接" class="headerlink" title="4.9 HTTP 的长链接"></a>4.9 HTTP 的长链接</h3><h3 id="4-10-GET-POST-PUT-DELETE-方法"><a href="#4-10-GET-POST-PUT-DELETE-方法" class="headerlink" title="4.10 GET/POST/PUT/DELETE 方法"></a>4.10 GET/POST/PUT/DELETE 方法</h3><h3 id="4-11-长链接时如何区分不同的请求？"><a href="#4-11-长链接时如何区分不同的请求？" class="headerlink" title="4.11 长链接时如何区分不同的请求？"></a>4.11 长链接时如何区分不同的请求？</h3><h3 id="4-12-cookie-和-session-的异同"><a href="#4-12-cookie-和-session-的异同" class="headerlink" title="4.12 cookie 和 session 的异同"></a>4.12 cookie 和 session 的异同</h3><h2 id="Part-5-系统设计"><a href="#Part-5-系统设计" class="headerlink" title="Part 5: 系统设计"></a>Part 5: 系统设计</h2><h3 id="5-1-什么是系统设计？"><a href="#5-1-什么是系统设计？" class="headerlink" title="5.1 什么是系统设计？"></a>5.1 什么是系统设计？</h3><h3 id="5-2-系统如何进行扩展？如用户增多之后，-qps上来了，-现有设计不再满足使用需求了，-要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了，-现有容量不够了）？"><a href="#5-2-系统如何进行扩展？如用户增多之后，-qps上来了，-现有设计不再满足使用需求了，-要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了，-现有容量不够了）？" class="headerlink" title="5.2 系统如何进行扩展？如用户增多之后， qps上来了， 现有设计不再满足使用需求了， 要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了， 现有容量不够了）？"></a>5.2 系统如何进行扩展？如用户增多之后， qps上来了， 现有设计不再满足使用需求了， 要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了， 现有容量不够了）？</h3><h3 id="5-3-故障如何处理？单点失效、多点失效和雪崩问题？"><a href="#5-3-故障如何处理？单点失效、多点失效和雪崩问题？" class="headerlink" title="5.3 故障如何处理？单点失效、多点失效和雪崩问题？"></a>5.3 故障如何处理？单点失效、多点失效和雪崩问题？</h3><h3 id="5-4-设计一个短网址系统"><a href="#5-4-设计一个短网址系统" class="headerlink" title="5.4 设计一个短网址系统"></a>5.4 设计一个短网址系统</h3><h3 id="5-5-设计一个秒杀系统"><a href="#5-5-设计一个秒杀系统" class="headerlink" title="5.5 设计一个秒杀系统"></a>5.5 设计一个秒杀系统</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文将整理 Python后端面试相关的比较重要的问题， 并列出主要相关知识点， 作为回答问题时的思路参考。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>面试问题整理</title>
    <link href="http://yoursite.com/2020/05/08/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/08/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2020-05-07T16:32:53.000Z</published>
    <updated>2020-05-08T13:35:54.451Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-python语言相比其他语言的优点和缺点"><a href="#1-python语言相比其他语言的优点和缺点" class="headerlink" title="1. python语言相比其他语言的优点和缺点"></a>1. python语言相比其他语言的优点和缺点</h4><p>编码结构风格： 去除花括号、分号等符号， 通过强制缩进来区分来标识代码块。这一点赞赏的人很多，排斥的人也很多， 当嵌套层级较深时， 代码段的排版可读性会下降；</p><a id="more"></a><p>强大的内建库： 使用内建库基本可以完成从web编程到GUI编程等各种领域的编程任务， 除了基本的数据结构以外， 还提供很多好用的高级数据结构， 如 deque 双端队列， heapq堆（可以用于构建最小堆， 解决TOPK问题）  等等；</p><p>活跃的社区， 有很多优秀的开源项目提供了各个业务领域的框架、工具类库， 从GUI编程到web编程到科学计算等等，可以快速实现功能，     满足业务需求</p><p>==&gt; </p><blockquote><p>开发效率高：Python的各个优点是相辅相成的。例如，Python语言因为有了丰富强大的类库，所以，Python的开发效率能够显著提高。相对于C、C++和Java等编译语言，Python开发者的效率提高了数倍。实现相同的功能，Python代码的文件往往只有C、C++和Java代码的1/5~1/3。虽然Python语言拥有很多吸引人的特性，但是，各大互联网公司广泛使用Python语言，很大程度上是因为Python语言开发效率高这个特点。开发效率高的语言，能够更好的满足互联网快速迭代的需求，因此，Python语言在互联网公司使用非常广泛。</p><p>应用领域广泛：Python语言的另一大优点就是应用领域广泛，工程师可以使用Python做很多的事情。例如，Web开发、网络编程、自动化运维、Linux系统管理、数据分析、科学计算、人工智能、机器学习等等。Python语言介于脚本语言和系统语言之间，我们根据需要，既可以将它当做一门脚本语言来编写脚本，也可以将它当做一个系统语言来编写服务</p></blockquote><p>缺点： python做工程化开发对开发者的要求较高， 需要自主遵守开发约束， 不然会灵活的动态语言特性会带来负面的影响， 如代码的健壮性会较差等等。</p><p>python的执行效率较差（但现在用pypy其实有很大的提升）</p><p>异步生态不完善， 目前3.x是原生支持异步的， 但相关的库较少， 比较出名的是 tornado</p><p>GIL的存在， 无法充分利用多核的特性（仅限 cython）</p><p>由于大家都觉得 python 简单， 在公司里面纷纷使用， 但是项目上又缺乏完善的文档， 必要的开发约定和约束， 导致做出来的项目难以扩展和维护， 增加新的特性往往导致项目项目代码更加混乱。</p><p>因为动态语言更加关注对象的属性和行为， 而不是对象的身份， 在函数和方法定义上并不对参数进行强制的类型检查， 这一做法使得在开发时， 很多时候并不需要对业务对象单独抽象， 而是可以使用内建字典、列表等数据结构来构造业务对象， 这就使得， 如果没有完善的文档， 会导致后期维护时不能马上识别对象含义以及所包含的属性和相应的处理方法。进一步， 在构建业务数据时， 如果数据源中有脏数据， 构建数据时未必会失败， 但是程序后续运行时可能会出现异常。所以， 使用 python 进行工程开发， 对文档、输入输出的处理有更高的要求。</p><p>语言的优缺点离不开项目背景， 没有最好或者最坏的语言， 只有最合适的语言</p><p>所以这道题结合工程场景来讲会比较恰当。</p><table><thead><tr><th>项目场景</th><th>核心诉求</th><th>语言选型</th></tr></thead><tbody><tr><td>原型开发验证</td><td>开发速度</td><td>python</td></tr><tr><td>脚本开发</td><td>便捷</td><td>python</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="2-什么是鸭子类型"><a href="#2-什么是鸭子类型" class="headerlink" title="2. 什么是鸭子类型"></a>2. 什么是鸭子类型</h4><p>鸭子类型是动态语言中的一种涉及风格，注重对象的行为而非对象的类型， 一个对象能否作为函数、表达式的参数， 取决于其行为（是否具备调用方所要求的方法）而非类型归属。GO也有鸭子类型。</p><h4 id="3-什么是猴子补丁技术？在什么场景下可以使用猴子补丁？有哪些案例？"><a href="#3-什么是猴子补丁技术？在什么场景下可以使用猴子补丁？有哪些案例？" class="headerlink" title="3. 什么是猴子补丁技术？在什么场景下可以使用猴子补丁？有哪些案例？"></a>3. 什么是猴子补丁技术？在什么场景下可以使用猴子补丁？有哪些案例？</h4><p>猴子补丁充分利用动态语言的特性。在运行时修改对象的属性和方法， gevent在这方面的运用较多。比如说程序早期开发时需求中只有狗这个对象， 狗有个叫的方法。但后来来了只猫， 而且只有一处会用到， 除了叫声和狗不一样以外， 其他属性没什么区别，这个时候可以在需要猫的地方， 通过初始化狗的实例， 然后用猴子补丁技术， 把叫声的方法替换掉。</p><h4 id="4-什么是自省（内省）？有什么用处？"><a href="#4-什么是自省（内省）？有什么用处？" class="headerlink" title="4. 什么是自省（内省）？有什么用处？"></a>4. 什么是自省（内省）？有什么用处？</h4><p>在一些语言中也被称为反射， 简单来说就是对象检查， 就好像你走到外面， 有些时候会遇到警察检查身份证和做一些盘问， 来确定对象的一些身份特点， 是什么(isinstance)， 有哪些属性(hasattr)， 有哪些行为(hasattr)。</p><p>python中同时有自省和反射的概念：</p><p>自省只用于检查对象更具体地讲， 是类型检查， 而反射既可以检查对象， 又可以修改对象。</p><blockquote><p> <a href="https://www.bnmetrics.com/blog/introspection-reflection-in-python" target="_blank" rel="noopener">https://www.bnmetrics.com/blog/introspection-reflection-in-python</a> </p></blockquote><p>在java中， 反射机制是说， 在运行状态中， 对于任何一个类， 都能知道这个类的所有属性和方法，对于任何一个对象， 都能调用它的任何一个方法和属性，这种动态获取新的以及动态调用对象方法的功能就叫做反射。</p><p>而java中也有自省的概念， 但是这个概念的范畴与python所指的自省范畴完全不同。</p><p>python中自省的方法主要有以下几个：</p><ul><li><p>hasattr</p></li><li><p>getattr</p></li><li><p>setattr</p></li><li><p>delattr</p></li><li><p>dir</p></li><li><p>isinstance</p></li><li><p>type</p></li><li><p>callable</p></li><li><p>inspect提供的方法</p></li></ul><h4 id="5-python中有哪些语法糖？有哪些常用的语法糖？"><a href="#5-python中有哪些语法糖？有哪些常用的语法糖？" class="headerlink" title="5. python中有哪些语法糖？有哪些常用的语法糖？"></a>5. python中有哪些语法糖？有哪些常用的语法糖？</h4><blockquote><p>先明确概念， 然后从概念的多方位去阐述</p><p>在计算机科学中，语法糖(syntactic sugar)是指编程语言中可以更容易的表达一个操作的语法，它可以使程序员更加容易去使用这门语言：操作可以变得更加清晰、方便，或者更加符合程序员的编程习惯。</p><p>编程语言提供的对于某种代码逻辑的更加简洁的表达方式</p><p>比如 索引切片， 运算符， 列表推导式，生成器推导式等等 </p></blockquote><h4 id="6-python3相比python2有哪些重要的变化？具体有什么影响？"><a href="#6-python3相比python2有哪些重要的变化？具体有什么影响？" class="headerlink" title="6. python3相比python2有哪些重要的变化？具体有什么影响？"></a>6. python3相比python2有哪些重要的变化？具体有什么影响？</h4><ol><li>较重大的改变：<ol><li>print 从语句变成函数</li><li>编码问题， 3默认使用unicode， 取消了 unicode 对象， 3中的str就相当于2的unicode， 2中str是字节， 3中的字节是bytes</li><li>除法变化， 3中除法返回浮点数</li><li>类型注解（type hint）， 帮助ide实现类型检查（也只是作为提醒而已）</li><li>优化super()方法， 方便直接调用父类函数</li><li>高级解包操作： a, b, *res = range(10)</li><li>增加 keyword only arguments 限定关键字参数</li><li>chained exception, python3 中重新抛出异常不会丢失堆栈信息</li></ol></li><li>新增特性：<ol><li>yield from 链接子生成器  # TODO: 需要实践一下的</li><li>asynico内置库， async/await 原生协程支持异步编程</li><li>新的内置库 enum， mock， asyncio， ipaddress， concurrent.futures等  # TODO: 需要实践</li><li>生成的 pyc 文件统一放到 <strong>pycache</strong></li><li>性能优化等</li></ol></li></ol><h4 id="7-如何将python2的代码迁移到python3？"><a href="#7-如何将python2的代码迁移到python3？" class="headerlink" title="7. 如何将python2的代码迁移到python3？"></a>7. 如何将python2的代码迁移到python3？</h4><p>pass</p><h4 id="8-为什么说函数是一等公民？"><a href="#8-为什么说函数是一等公民？" class="headerlink" title="8. 为什么说函数是一等公民？"></a>8. 为什么说函数是一等公民？</h4><p>pass</p><h4 id="9-函数和方法的区别？"><a href="#9-函数和方法的区别？" class="headerlink" title="9. 函数和方法的区别？"></a>9. 函数和方法的区别？</h4><p>pass</p><h4 id="10-函数的传参过程是怎么样的？实参跟形参有什么区别？"><a href="#10-函数的传参过程是怎么样的？实参跟形参有什么区别？" class="headerlink" title="10. 函数的传参过程是怎么样的？实参跟形参有什么区别？"></a>10. 函数的传参过程是怎么样的？实参跟形参有什么区别？</h4><p>pass</p><h4 id="11-参数类型有哪些？"><a href="#11-参数类型有哪些？" class="headerlink" title="11. 参数类型有哪些？"></a>11. 参数类型有哪些？</h4><p>pass</p><h4 id="12-传参时有哪些要注意的问题？"><a href="#12-传参时有哪些要注意的问题？" class="headerlink" title="12. 传参时有哪些要注意的问题？"></a>12. 传参时有哪些要注意的问题？</h4><p>pass</p><h4 id="13-python中有哪些可变对象？哪些不可变对象？"><a href="#13-python中有哪些可变对象？哪些不可变对象？" class="headerlink" title="13. python中有哪些可变对象？哪些不可变对象？"></a>13. python中有哪些可变对象？哪些不可变对象？</h4><p>pass</p><h4 id="14-生成器与迭代器有什么区别？"><a href="#14-生成器与迭代器有什么区别？" class="headerlink" title="14. 生成器与迭代器有什么区别？"></a>14. 生成器与迭代器有什么区别？</h4><p>pass</p><h4 id="15-如何实现协程？"><a href="#15-如何实现协程？" class="headerlink" title="15. 如何实现协程？"></a>15. 如何实现协程？</h4><p>pass</p><h4 id="16-python中如何进行异常处理？如何自定义一个异常类？"><a href="#16-python中如何进行异常处理？如何自定义一个异常类？" class="headerlink" title="16. python中如何进行异常处理？如何自定义一个异常类？"></a>16. python中如何进行异常处理？如何自定义一个异常类？</h4><p>pass</p><h4 id="17-什么时候需要捕获异常？"><a href="#17-什么时候需要捕获异常？" class="headerlink" title="17. 什么时候需要捕获异常？"></a>17. 什么时候需要捕获异常？</h4><p>pass</p><h4 id="18-什么是单元测试？python中如何进行单元测试？"><a href="#18-什么是单元测试？python中如何进行单元测试？" class="headerlink" title="18. 什么是单元测试？python中如何进行单元测试？"></a>18. 什么是单元测试？python中如何进行单元测试？</h4><p>pass</p><h4 id="19-什么是浅拷贝？什么是深拷贝？-如何实现深拷贝？"><a href="#19-什么是浅拷贝？什么是深拷贝？-如何实现深拷贝？" class="headerlink" title="19. 什么是浅拷贝？什么是深拷贝？ 如何实现深拷贝？"></a>19. 什么是浅拷贝？什么是深拷贝？ 如何实现深拷贝？</h4><p>pass</p><h4 id="20-python如何管理依赖？"><a href="#20-python如何管理依赖？" class="headerlink" title="20. python如何管理依赖？"></a>20. python如何管理依赖？</h4><p>pass</p><h4 id="21-如何分析python代码的性能？如何优化python的性能？"><a href="#21-如何分析python代码的性能？如何优化python的性能？" class="headerlink" title="21. 如何分析python代码的性能？如何优化python的性能？"></a>21. 如何分析python代码的性能？如何优化python的性能？</h4><p>pass</p><h4 id="22-什么是GIL？如何规避GIL的影响？"><a href="#22-什么是GIL？如何规避GIL的影响？" class="headerlink" title="22. 什么是GIL？如何规避GIL的影响？"></a>22. 什么是GIL？如何规避GIL的影响？</h4><p>pass</p><h4 id="23-python有哪些内置数据结构？"><a href="#23-python有哪些内置数据结构？" class="headerlink" title="23. python有哪些内置数据结构？"></a>23. python有哪些内置数据结构？</h4><p>pass</p><h4 id="24-列表和元组有什么区别？"><a href="#24-列表和元组有什么区别？" class="headerlink" title="24. 列表和元组有什么区别？"></a>24. 列表和元组有什么区别？</h4><p>pass</p><h4 id="25-python的字典是如何实现的？"><a href="#25-python的字典是如何实现的？" class="headerlink" title="25. python的字典是如何实现的？"></a>25. python的字典是如何实现的？</h4><p>pass</p><h4 id="26-什么是随机访问？"><a href="#26-什么是随机访问？" class="headerlink" title="26. 什么是随机访问？"></a>26. 什么是随机访问？</h4><p>pass</p><h4 id="27-内置数据结构常用操作的时间复杂度？"><a href="#27-内置数据结构常用操作的时间复杂度？" class="headerlink" title="27. 内置数据结构常用操作的时间复杂度？"></a>27. 内置数据结构常用操作的时间复杂度？</h4><p>pass</p><h4 id="28-进程、线程、协程的区别"><a href="#28-进程、线程、协程的区别" class="headerlink" title="28. 进程、线程、协程的区别"></a>28. 进程、线程、协程的区别</h4><p>进程：  资源</p><p>线程：  活动单位</p><p>进程就像校园会里的一个班级， 学校为每个班级在操场上划定了地方， 配给了物资， 而班上的每个同学就像线程， 在自己的班级里取用物资， 通常情况下没法拿到别的班级的物资。</p><p>每个CPU核心， 只能在同一时刻运行一组指令， 意味着同一时刻， 一个核心上只有一个线程在执行。</p><p>==&gt; 并行和并发的概念：</p><p>并行： 多核CPU可以同时承载多个线程活动</p><p>并发： 并发是与IO场景密切相关的概念。其中又分为同步、异步、阻塞、非阻塞这四个核心概念。</p><p>操作系统一共有五种IO模型： 阻塞IO型， 非阻塞IO型， IO复用模型， 信号驱动IO模型和异步IO模型。</p><p>而并发就是 <code>异步非阻塞</code> 状态下的一种形式，当程序执行操作 a 时，使 a 的 I/O 异步操作，这时程序去执行操作 b, 在外部看来，a 和 b 时同时被执行的，然而他们只运行在在一个线程当中。</p><p>与线程、进程不同的是，协程并不是操作系统物理层面存在的一种程序。</p><p>协程是程序级别的，由程序编写者自己操控整个协程的生命周期。这样就实现了类似操作系统操作多线程一样的效果，但是省下了现成的切换中造成的资源消耗。</p><p>而通过程序来操纵协程，就造成了cpu 一直在运行，并且是多个协程一直在运行的假象，也就变成了并发。</p><blockquote><p>作者：咕咕咕爱学习链接：<a href="https://juejin.im/post/5e0ee7195188253abd7d2c54来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。" target="_blank" rel="noopener">https://juejin.im/post/5e0ee7195188253abd7d2c54来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p></blockquote><h4 id="29-线程间通信"><a href="#29-线程间通信" class="headerlink" title="29. 线程间通信"></a>29. 线程间通信</h4><ul><li>互斥量（锁）：通过互斥机制防止多个线程同时访问公共资源</li><li>信号量： 控制同一时刻多个线程访问同一个资源</li><li>事件： 通过通知的方式保持多个线程同步</li></ul><h4 id="30-进程间通信"><a href="#30-进程间通信" class="headerlink" title="30. 进程间通信"></a>30. 进程间通信</h4><ul><li>管道/匿名管道/有名管道</li><li>信号： Ctrl + c 产生 SIGINT 程序终止信号</li><li>消息队列：</li><li>共享内存</li><li>信号量</li><li>socket： 最常用的方式</li></ul><h4 id="31-linux的内存管理机制"><a href="#31-linux的内存管理机制" class="headerlink" title="31. linux的内存管理机制"></a>31. linux的内存管理机制</h4><p>pass</p><h4 id="32-linux常用命令"><a href="#32-linux常用命令" class="headerlink" title="32. linux常用命令"></a>32. linux常用命令</h4><p>pass</p><h4 id="33-什么是闭包？"><a href="#33-什么是闭包？" class="headerlink" title="33. 什么是闭包？"></a>33. 什么是闭包？</h4><p>pass</p><h4 id="34-实现一个装饰器"><a href="#34-实现一个装饰器" class="headerlink" title="34. 实现一个装饰器"></a>34. 实现一个装饰器</h4><p>pass</p><h4 id="35-实现一个装饰器工厂"><a href="#35-实现一个装饰器工厂" class="headerlink" title="35. 实现一个装饰器工厂"></a>35. 实现一个装饰器工厂</h4><p>pass</p><h4 id="36-装饰器通常用来实现什么功能？"><a href="#36-装饰器通常用来实现什么功能？" class="headerlink" title="36. 装饰器通常用来实现什么功能？"></a>36. 装饰器通常用来实现什么功能？</h4><p>pass</p><h4 id="37-工厂模式"><a href="#37-工厂模式" class="headerlink" title="37. 工厂模式"></a>37. 工厂模式</h4><p>pass</p><h4 id="38-构造模式"><a href="#38-构造模式" class="headerlink" title="38. 构造模式"></a>38. 构造模式</h4><p>pass</p><h4 id="39-原型模式"><a href="#39-原型模式" class="headerlink" title="39. 原型模式"></a>39. 原型模式</h4><p>pass</p><h4 id="40-单例模式"><a href="#40-单例模式" class="headerlink" title="40. 单例模式"></a>40. 单例模式</h4><p>pass</p><h4 id="41-装饰器模式"><a href="#41-装饰器模式" class="headerlink" title="41. 装饰器模式"></a>41. 装饰器模式</h4><p>pass</p><h4 id="42-代理模式"><a href="#42-代理模式" class="headerlink" title="42. 代理模式"></a>42. 代理模式</h4><p>pass</p><h4 id="43-适配器模式"><a href="#43-适配器模式" class="headerlink" title="43. 适配器模式"></a>43. 适配器模式</h4><p>pass</p><h4 id="44-外观模式"><a href="#44-外观模式" class="headerlink" title="44. 外观模式"></a>44. 外观模式</h4><p>pass</p><h4 id="45-享元模式"><a href="#45-享元模式" class="headerlink" title="45. 享元模式"></a>45. 享元模式</h4><p>pass</p><h4 id="46-MVC模式"><a href="#46-MVC模式" class="headerlink" title="46. MVC模式"></a>46. MVC模式</h4><p>pass</p><h4 id="47-惰性计算模式"><a href="#47-惰性计算模式" class="headerlink" title="47. 惰性计算模式"></a>47. 惰性计算模式</h4><p>pass</p><h4 id="48-迭代器模式"><a href="#48-迭代器模式" class="headerlink" title="48. 迭代器模式"></a>48. 迭代器模式</h4><p>pass</p><h4 id="49-观察者模式"><a href="#49-观察者模式" class="headerlink" title="49. 观察者模式"></a>49. 观察者模式</h4><p>pass</p><h4 id="50-策略模式"><a href="#50-策略模式" class="headerlink" title="50. 策略模式"></a>50. 策略模式</h4><p>pass</p><h4 id="51-python中有哪些高阶函数？什么叫高阶函数？"><a href="#51-python中有哪些高阶函数？什么叫高阶函数？" class="headerlink" title="51. python中有哪些高阶函数？什么叫高阶函数？"></a>51. python中有哪些高阶函数？什么叫高阶函数？</h4><p>pass</p><h4 id="52-什么是面向对象？"><a href="#52-什么是面向对象？" class="headerlink" title="52. 什么是面向对象？"></a>52. 什么是面向对象？</h4><p>pass</p><h4 id="53-面向对象有哪些特征？"><a href="#53-面向对象有哪些特征？" class="headerlink" title="53. 面向对象有哪些特征？"></a>53. 面向对象有哪些特征？</h4><p>pass</p><h4 id="54-什么是元编程？有哪些案例？"><a href="#54-什么是元编程？有哪些案例？" class="headerlink" title="54. 什么是元编程？有哪些案例？"></a>54. 什么是元编程？有哪些案例？</h4><p>pass</p><h4 id="55-什么是类元编程？"><a href="#55-什么是类元编程？" class="headerlink" title="55. 什么是类元编程？"></a>55. 什么是类元编程？</h4><p>pass</p><h4 id="56-类是谁的对象？type是谁的对象？"><a href="#56-类是谁的对象？type是谁的对象？" class="headerlink" title="56. 类是谁的对象？type是谁的对象？"></a>56. 类是谁的对象？type是谁的对象？</h4><p>pass</p><h4 id="57-python的垃圾回收机制"><a href="#57-python的垃圾回收机制" class="headerlink" title="57. python的垃圾回收机制"></a>57. python的垃圾回收机制</h4><p>pass</p><h4 id="58-浏览器输入一个url中间经历的过程"><a href="#58-浏览器输入一个url中间经历的过程" class="headerlink" title="58. 浏览器输入一个url中间经历的过程"></a>58. 浏览器输入一个url中间经历的过程</h4><p> <img src="https://upload-images.jianshu.io/upload_images/2075673-3afda32a13a68c6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"> </p><p>涉及的过程、涉及的协议、每个协议的作用， 通常在建立完TCP连接这部分往下， 讲到HTTP报文的流转时，面试管不追问， 就没必要往下讲， 消息的流转在请求放这边， 从应用层往下， 消息经过五层网络模型不断被拆解和封装， 到了响应方那边， 自底向上不断解封还原， 送达服务器。</p><p>DNS查询， TCP握手， HTTP请求，反向代理nginx， uwsgi/gunicorn， web app响应， TCP挥手</p><ol><li><p>要建立一个 tcp 通信， 就必须知道服务器进程在网络上的位置， 也就是IP+端口， 这是网络进程寻址的依据；</p></li><li><p>端口本身是URL组成的一部分， 因此浏览器的第一步是要根据域名拿到服务器的IP地址。</p><p>【展开回答】解析DNS的过程：</p><p>_&lt;既然是缓存， 那就会有过期时间&gt;_</p><ol><li>浏览器查找自己的DNS缓存， 如果有就直接返回（chrome DNS 缓存时间为1分钟）；</li><li>操作系统查找自己的DNS缓存， 如果有就返回给浏览器（ OS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。 ）</li><li>操作系统查找自己的本地host文件， 如果有就返回给浏览器；</li><li>操作系统向本地域名服务器发起请求， 查询本地DNS缓存，如果有， 返回给OS，然后OS返回给浏览器；</li><li>OS向root DNS发起请求得到顶级域名服务器的IP，然后root DNS向顶级域名服务器发起请求得到权威域名服务器的IP， 顶级域名服务器再向权威域名服务器发起请求得到目标域名的IP， 本地域名服务器将其返回给OS， 并且将该域名的解析IP缓存起来，OS将IP返回给浏览器， 并做缓存</li></ol><p>DNS协议也是属于应用层协议，因此有也存在客户端和服务端。</p></li><li><p>拿到IP后， 就可以向目标主机发起请求， 经过三次握手建立TCP连接；</p><p>【展开回答】三次握手的细节，每一次握手， 谁向谁发了消息， 发送的消息是什么</p><p>client ————— syn1 ————–&gt;  server</p><p>client &lt;—- syn2, ack1=syn1+1 —– server</p><p>client ————– ack2=syn2+1 —-&gt; server</p></li><li><p>发起HTTP请求</p></li><li><p>接收服务器响应</p></li><li><p>浏览器解析HTML， 获取静态资源</p><p>【展开回答】这里可以牵扯到 HTTP 1.0 非持久连接 及 HTTP 1.1 持久性连接 下， 该步骤的区别</p></li><li><p>关闭TCP连接</p></li><li><p>浏览器渲染页面</p></li></ol><h4 id="59-网络的分层模型"><a href="#59-网络的分层模型" class="headerlink" title="59. 网络的分层模型"></a>59. 网络的分层模型</h4><p>OSI标准网络模型是七层的， 从上到下依次是 应用层 -&gt; 表示层 -&gt; 会话层 -&gt; 传输层 -&gt; 网络层 -&gt; 数据链路层 -&gt; 物理层。</p><h4 id="60-TCP的握手过程"><a href="#60-TCP的握手过程" class="headerlink" title="60. TCP的握手过程"></a>60. TCP的握手过程</h4><p>pass</p><h4 id="61-TCP的挥手过程"><a href="#61-TCP的挥手过程" class="headerlink" title="61. TCP的挥手过程"></a>61. TCP的挥手过程</h4><p>pass</p><h4 id="62-TCP-跟-UDP-的差别"><a href="#62-TCP-跟-UDP-的差别" class="headerlink" title="62. TCP 跟 UDP 的差别"></a>62. TCP 跟 UDP 的差别</h4><p>pass</p><h4 id="63-HTTP请求由哪些部分组成？"><a href="#63-HTTP请求由哪些部分组成？" class="headerlink" title="63. HTTP请求由哪些部分组成？"></a>63. HTTP请求由哪些部分组成？</h4><p>pass</p><p>状态行， 请求头， 消息主体</p><h4 id="64-HTTP响应由哪些部分组成？"><a href="#64-HTTP响应由哪些部分组成？" class="headerlink" title="64. HTTP响应由哪些部分组成？"></a>64. HTTP响应由哪些部分组成？</h4><p>pass</p><h4 id="65-常见的HTTP响应状态码"><a href="#65-常见的HTTP响应状态码" class="headerlink" title="65. 常见的HTTP响应状态码"></a>65. 常见的HTTP响应状态码</h4><blockquote><p>200  301  302  400  403  500</p></blockquote><h4 id="66-什么是幂等方法，-哪些HTTP方法是幂等的？"><a href="#66-什么是幂等方法，-哪些HTTP方法是幂等的？" class="headerlink" title="66. 什么是幂等方法， 哪些HTTP方法是幂等的？"></a>66. 什么是幂等方法， 哪些HTTP方法是幂等的？</h4><blockquote><p>对服务器有没有副作用</p></blockquote><h4 id="67-HTTP的长链接"><a href="#67-HTTP的长链接" class="headerlink" title="67. HTTP的长链接"></a>67. HTTP的长链接</h4><p>pass</p><h4 id="68-GET-POST-PUT-DELETE"><a href="#68-GET-POST-PUT-DELETE" class="headerlink" title="68. GET/POST/PUT/DELETE"></a>68. GET/POST/PUT/DELETE</h4><p>pass</p><h4 id="69-长链接时如何区分不同的请求？"><a href="#69-长链接时如何区分不同的请求？" class="headerlink" title="69. 长链接时如何区分不同的请求？"></a>69. 长链接时如何区分不同的请求？</h4><blockquote><p>Content-Length | Transfer-Encoding</p></blockquote><h4 id="70-Cookie-和-Session-的异同"><a href="#70-Cookie-和-Session-的异同" class="headerlink" title="70. Cookie 和 Session 的异同"></a>70. Cookie 和 Session 的异同</h4><p>pass</p><h4 id="71-TCP编程的原理"><a href="#71-TCP编程的原理" class="headerlink" title="71. TCP编程的原理"></a>71. TCP编程的原理</h4><p>pass</p><h4 id="72-如何使用socket编程发送-HTTP-请求？"><a href="#72-如何使用socket编程发送-HTTP-请求？" class="headerlink" title="72. 如何使用socket编程发送 HTTP 请求？"></a>72. 如何使用socket编程发送 HTTP 请求？</h4><p>pass</p><h4 id="73-阻塞-socket，-非阻塞-socket"><a href="#73-阻塞-socket，-非阻塞-socket" class="headerlink" title="73. 阻塞 socket， 非阻塞 socket"></a>73. 阻塞 socket， 非阻塞 socket</h4><blockquote><p>HTTP建立在TCP基础之上</p><p>HTTP是基于文本的协议</p></blockquote><h4 id="74-IO多路复用机制"><a href="#74-IO多路复用机制" class="headerlink" title="74. IO多路复用机制"></a>74. IO多路复用机制</h4><h4 id="75-五种IO模型分别是什么？对应的IO模型"><a href="#75-五种IO模型分别是什么？对应的IO模型" class="headerlink" title="75. 五种IO模型分别是什么？对应的IO模型"></a>75. 五种IO模型分别是什么？对应的IO模型</h4><blockquote><p>Blocking IO</p><p>Nonblocking IO</p><p>IO multiplexing (IO多路复用)   框架常用 IO 多路复用来提高并发能力</p><p>Signal Driven IO</p><p>Asynchronous IO(异步IO)</p></blockquote><h4 id="76-如何提升服务器的并发能力"><a href="#76-如何提升服务器的并发能力" class="headerlink" title="76. 如何提升服务器的并发能力"></a>76. 如何提升服务器的并发能力</h4><blockquote><p>多线程模型， 创建新的线程处理请i去</p><p>多进程模型， 创建新的进程处理请求</p><p>IO多路复用， 实现单进程同时处理多个SOCKET（同时监听多个socket）</p></blockquote><h4 id="77-什么是IO多路复用"><a href="#77-什么是IO多路复用" class="headerlink" title="77. 什么是IO多路复用"></a>77. 什么是IO多路复用</h4><blockquote><p>操作系统提供的同时监听多个socket的机制（select，poll，  epoll）</p></blockquote><h4 id="78-select-poll-epoll的区别"><a href="#78-select-poll-epoll的区别" class="headerlink" title="78. select/poll/epoll的区别"></a>78. select/poll/epoll的区别</h4><blockquote><p><img src="C:%5CUsers%5Carclv%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200411104747726.png" alt="image-20200411104747726"></p></blockquote><h4 id="79-python中实现IO多路复用"><a href="#79-python中实现IO多路复用" class="headerlink" title="79. python中实现IO多路复用"></a>79. python中实现IO多路复用</h4><blockquote><p><img src="C:%5CUsers%5Carclv%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200411104901957.png" alt="image-20200411104901957"></p></blockquote><h4 id="80-python常用的并发网络库"><a href="#80-python常用的并发网络库" class="headerlink" title="80. python常用的并发网络库"></a>80. python常用的并发网络库</h4><blockquote><p>tornado, gevent, asyncio</p></blockquote><h4 id="81-使用tornado构建微服务，-实现-restful-接口"><a href="#81-使用tornado构建微服务，-实现-restful-接口" class="headerlink" title="81. 使用tornado构建微服务， 实现 restful 接口"></a>81. 使用tornado构建微服务， 实现 restful 接口</h4><blockquote><p>底层基于linux多路复用</p><p>可以通过协程或者回调实现异步编程</p><p>生态不完善， 响应的异步框架（ORM）缺失</p></blockquote><h4 id="82-gevent-的并发实现"><a href="#82-gevent-的并发实现" class="headerlink" title="82. gevent 的并发实现"></a>82. gevent 的并发实现</h4><blockquote><p>基于轻量级“绿色线程（greenlet）” 实现并发</p><p>gevent修改了内置的socket改为非阻塞</p><p>gunicorn + gevent 部署作为 wsgi server</p><p>《Gevent程序员指南》</p></blockquote><h4 id="83-mysql事务原理，-特性，-事务并发控制"><a href="#83-mysql事务原理，-特性，-事务并发控制" class="headerlink" title="83. mysql事务原理， 特性， 事务并发控制"></a>83. mysql事务原理， 特性， 事务并发控制</h4><blockquote><p>事务 = Transaction</p><p>事务是数据库并发控制的基本单位</p><p>事务可以看作是一系列SQL语句的集合</p><p>事务必须要么全部执行成功， 要么全部执行失败（回滚）</p><p>转账操作是常见场景</p><p>ACID是事务的四个基本特性</p><p>原子性（Atomicity）： 一个事务中的所有操作全部完成或失败</p><p>一致性（Consistency）：事务开始和结束之后数据完整性没有被破坏</p><p>隔离性（Isolation）：允许多个事务同时对数据库修改和读写</p><p>持久性（Durability）： 事务结束之后， 修改是永久的不会丢失</p></blockquote><h4 id="84-事务缺乏并发控制会长生哪些异常？"><a href="#84-事务缺乏并发控制会长生哪些异常？" class="headerlink" title="84. 事务缺乏并发控制会长生哪些异常？"></a>84. 事务缺乏并发控制会长生哪些异常？</h4><blockquote><ol><li>幻读（phantom read）： 一个事务第二次查出现第一次没有的结果（别的事务成功）</li><li>非重复读（nonrepeatable read）：一个事务重复读两次得到不同的结果</li><li>脏读（dirty read）：一个事务读取到另一个事务没有提交的修改</li><li>丢失修改（lost update）：并发写入造成其中一些修改丢失</li></ol></blockquote><h4 id="85-事务的四种隔离级别"><a href="#85-事务的四种隔离级别" class="headerlink" title="85. 事务的四种隔离级别"></a>85. 事务的四种隔离级别</h4><blockquote><p>读未提交（read uncommitted）：别的事务可以读取到未提交改变</p><p>读已提交（read committed）：只能读取已经提交的数据</p><p>可重复读（repeatable read）：同一个事务先后查询结果一样（默认隔离级别）</p><p>串行化（Serializable）：事务完全串行化的执行， 隔离级别最高，执行效率最低（事务执行的时候锁住， 直到一个事务结束才能执行另一个事务）</p></blockquote><h4 id="86-如何解决高并发场景下的插入重复"><a href="#86-如何解决高并发场景下的插入重复" class="headerlink" title="86. 如何解决高并发场景下的插入重复"></a>86. 如何解决高并发场景下的插入重复</h4><blockquote><ol><li>使用数据库的唯一索引（分库分表不适用）</li><li>使用队列异步写入</li><li>使用 redis 等实现分布式锁</li></ol></blockquote><h4 id="87-什么是悲观锁"><a href="#87-什么是悲观锁" class="headerlink" title="87. 什么是悲观锁"></a>87. 什么是悲观锁</h4><blockquote><p>假设操作时一定会有别的事务同时进行修改， 因此悲观锁时先获取锁再进行操作， 一锁二查三更新 select for update</p></blockquote><h4 id="88-什么是乐观锁"><a href="#88-什么是乐观锁" class="headerlink" title="88. 什么是乐观锁"></a>88. 什么是乐观锁</h4><blockquote><p>假设操作时不会有别的事务同时进行修改， 因此乐观送先修改，更新时发现数据已经变了就回滚 check and set</p><p>乐观锁一般通过版本号或者时间戳实现（检查）</p></blockquote><h4 id="89-乐观锁和悲观锁的选择"><a href="#89-乐观锁和悲观锁的选择" class="headerlink" title="89. 乐观锁和悲观锁的选择"></a>89. 乐观锁和悲观锁的选择</h4><blockquote><p>需要更具响应速度、冲突频率、重试代价来判断使用哪一种</p><p>给一些场景出来</p></blockquote><h4 id="90-mysql常用数据类型："><a href="#90-mysql常用数据类型：" class="headerlink" title="90. mysql常用数据类型："></a>90. mysql常用数据类型：</h4><blockquote><p>-字符串</p><p>CHAR  存定长字符串</p><p>VARCHAR  存不定长字符换 0~65535个字符</p><p>TINYTEXT  最长255个字符</p><p>TEXT 最长65535个字符</p><p>-数值（记住数值范围）</p><p>-日期</p></blockquote><h4 id="91-Mysql数据库引擎"><a href="#91-Mysql数据库引擎" class="headerlink" title="91. Mysql数据库引擎"></a>91. Mysql数据库引擎</h4><blockquote><p>InnoDB 和 MyISAM 的区别</p><p>MyISAM 不支持事务</p><p>InnoDB 支持事务</p><p>MyISAM 不支持外键， InnoDB支持</p><p>MyISAM只支持表锁， InnoDB支持行锁和表锁（并发粒度控制更细）</p><p>MyISAM支持全文索引， InnoDB不支持全文索引</p></blockquote><h4 id="92-什么是索引"><a href="#92-什么是索引" class="headerlink" title="92. 什么是索引"></a>92. 什么是索引</h4><blockquote><p>索引是数据表中一个或者多个列进行排序的数据结构</p><p>索引能够大幅提升检索速度</p><p>创建、更新索引本身会消耗时间和空间</p></blockquote><h4 id="93-mysql索引的数据结构"><a href="#93-mysql索引的数据结构" class="headerlink" title="93.mysql索引的数据结构"></a>93.mysql索引的数据结构</h4><blockquote><p>B-Trees</p><p>为什么是B树？涉及查找结构的进化史</p><p>线性查找 &gt; 二分查找（要求有序结构， 插入慢） &gt; HASH（查询快， 占用空间， 不适合存储大规模数据）&gt; 二叉查找树（插入和查询很快， 不适合存储大规模数据， 复杂度退化）&gt; 平衡树（解决二叉查找树的退化问题， 结点非常多的时候树高依然很高）&gt; 多路查找树（结点过多树高不会特别深）&gt; 多路平衡查找树（无法实现范围查找） &gt; B+Tree</p><p>B-TREES就是一个多路平衡查找树</p><p>特点： </p><p>每个节点最多 m 个孩子， 称为 m 阶或者度</p><p>叶节点具有相同的深度</p><p>节点中的数据 key 从左到右是递增的</p><p>资源： Data Structure Visualizations</p><p>Mysql使用B+TREE作为索引的结构</p><p>B+TREE是B-TREES的变形</p><p>只在叶子节点带有指向记录的指针（可以增加树的度）</p><p>叶子节点通过指针相连（可以实现范围查找）</p><p>阶数的确定跟磁盘块的大小有关（为了操作系统更好地读取和缓存数据）</p></blockquote><p><img src="C:%5CUsers%5Carclv%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200411173009851.png" alt="image-20200411173009851"></p><h4 id="94-mysql的索引"><a href="#94-mysql的索引" class="headerlink" title="94. mysql的索引"></a>94. mysql的索引</h4><blockquote><p>普通索引</p><p>唯一索引</p><p>多列索引</p><p>主键索引（一个表只能有一个）</p><p>全文索引</p></blockquote><h4 id="95-什么时候创建索引？有什么需要注意的？"><a href="#95-什么时候创建索引？有什么需要注意的？" class="headerlink" title="95. 什么时候创建索引？有什么需要注意的？"></a>95. 什么时候创建索引？有什么需要注意的？</h4><blockquote><p>建表的时候需要更具查询需求来创建索引</p><pre><code>- 经常用作查询条件的字段- 经常用作表连接的字段- 经常出现在 order by, group by 之后的字段</code></pre><p>最佳实践：</p><pre><code>- 对非空字段 NOT NULL 创建索引，mysql很难对空值做查询优化- 区分度高， 离散度大， 作为索引的字段值尽量不要有大量相同的值- 索引的长度不要太长（比较时耗费之间）</code></pre></blockquote><h4 id="96-索引什么时候失效"><a href="#96-索引什么时候失效" class="headerlink" title="96. 索引什么时候失效"></a>96. 索引什么时候失效</h4><blockquote><p>记忆口诀： 模糊匹配， 类型隐转、最左匹配</p><ol><li>以 % 开头的 LIKE 语句， 模糊搜索</li><li>出现类型隐式转换</li><li>没有满足最左前缀原则</li></ol><p>都会导致key无法直接比较</p></blockquote><h4 id="97-什么是聚集索引，-什么是非聚集索引？"><a href="#97-什么是聚集索引，-什么是非聚集索引？" class="headerlink" title="97. 什么是聚集索引， 什么是非聚集索引？"></a>97. 什么是聚集索引， 什么是非聚集索引？</h4><blockquote><p>聚集还是非聚集指的是 B+TREE叶节点存的是指针还是数据记录</p><p>MyISAM索引和数据分离，使用的是非聚集索引</p><p>InnoDB数据文件就是索引文件， 主键索引就是聚集索引</p></blockquote><h4 id="98-如何排查慢查询"><a href="#98-如何排查慢查询" class="headerlink" title="98. 如何排查慢查询"></a>98. 如何排查慢查询</h4><blockquote><p>慢查询通常是缺少索引， 索引不合理或者业务代码导致</p><p>slow_query_log_file 开启并且慢查询查询日志</p><p>通过 explain 排查索引问题</p><p>调整数据修改索引</p><p>业务代码限制不合理访问（如分页查询）</p></blockquote><h4 id="99-什么是内连接、外连接、全连接"><a href="#99-什么是内连接、外连接、全连接" class="headerlink" title="99. 什么是内连接、外连接、全连接"></a>99. 什么是内连接、外连接、全连接</h4><blockquote><p>内连接 INNER JOIN</p><p>外连接 LEFT JOIN / RIGHT JOIN</p><p>全连接 FULL JOIN</p></blockquote><h4 id="100-缓存的使用场景"><a href="#100-缓存的使用场景" class="headerlink" title="100. 缓存的使用场景"></a>100. 缓存的使用场景</h4><blockquote><p>缓解关系数据库并发访问的压力： 热点数据</p><p>减少响应时间：内存IO速度比磁盘快</p><p>提升吞吐量：redis等内存数据库单机就可以支撑很大并发</p></blockquote><h4 id="101-redis和memcached的主要区别"><a href="#101-redis和memcached的主要区别" class="headerlink" title="101. redis和memcached的主要区别"></a>101. redis和memcached的主要区别</h4><blockquote><p>redis 数据存储类型丰富</p><p>网络IO模型不同， redis是IO多路复用</p><p>redis有持久化支持</p></blockquote><p><img src="C:%5CUsers%5Carclv%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200411182758145.png" alt="image-20200411182758145"></p><h4 id="102-请简述-redis-常用数据类型和使用场景"><a href="#102-请简述-redis-常用数据类型和使用场景" class="headerlink" title="102. 请简述 redis 常用数据类型和使用场景"></a>102. 请简述 redis 常用数据类型和使用场景</h4><blockquote><p>string： 用来实现简单的KV键值对存储， 如计数器</p><p>List(链表)：实现双向链表， 如用户的关注， 粉丝列表</p><p>Hash（哈希表）：用来存储彼此相关信息的键值对(HSET key field value)</p><p>Set（集合）： 存储不重复元素， 比如用户的关注者</p><p>Sorted Set（有序集合）： 实时信息排行榜</p><p>以下不常用：</p><p>pipline</p><p>发布订阅</p></blockquote><h4 id="103-redis数据类型的内置实现"><a href="#103-redis数据类型的内置实现" class="headerlink" title="103. redis数据类型的内置实现"></a>103. redis数据类型的内置实现</h4><blockquote><p>String: 整数或者sds(simple dynamic string)</p><p>List: ziplist（压缩链表，连续的内存)或者双端链表</p><p>Hash：ziplist 或者 hashtable</p><p>Set：intset 或者 hashtable</p><p>SortedSet： skiplist 跳跃表</p></blockquote><h4 id="104-redis有哪些持久化方式"><a href="#104-redis有哪些持久化方式" class="headerlink" title="104. redis有哪些持久化方式"></a>104. redis有哪些持久化方式</h4><blockquote><p>快照方式：把数据快照放在磁盘二进制文件中 dump.rdb</p><p>AOF（Append Only File）: 每一个写命令追加到文件</p></blockquote><h4 id="105-什么是-redis-事务"><a href="#105-什么是-redis-事务" class="headerlink" title="105. 什么是 redis 事务"></a>105. 什么是 redis 事务</h4><blockquote><p>将多个请求打包， 一次性， 按序执行多个命令的机制</p><p>redis 通过 multi, exec, watch 等命令实现事务功能</p></blockquote><h4 id="106-redis如何实现分布式锁"><a href="#106-redis如何实现分布式锁" class="headerlink" title="106. redis如何实现分布式锁"></a>106. redis如何实现分布式锁</h4><blockquote><p>使用 setnx 实现枷锁， 可以同时通过 expire 添加超时时间</p><p>锁的 value 值可以使用一个随机的 uuid 或者特定的命名</p><p>释放锁的时候，通过 uuid 判断是否是该锁， 是则执行 delete 释放锁</p></blockquote><h4 id="107-使用缓存的模式？"><a href="#107-使用缓存的模式？" class="headerlink" title="107. 使用缓存的模式？"></a>107. 使用缓存的模式？</h4><blockquote><p>常用的缓存使用模式：</p><p>Cache Aside： 同时更新缓存和数据库（常用）</p><p>Reaghd / Write Through： 先更新缓存， 缓存负责同步更新数据库</p><p>Write Behind Caching：先更新缓存， 缓存定期异步更新数据库</p></blockquote><p>选择使用模式的底层逻辑：数据库和缓存之间的数据一致性问题</p><p>模式1： 先更新数据库后更新缓存，当存在并发的写操作时， 操作可能导致缓存读取的是脏数据；解决： 先更新数据库， 然后删除缓存，下次读的时候重建缓存</p><h4 id="108-什么是缓存穿透"><a href="#108-什么是缓存穿透" class="headerlink" title="108. 什么是缓存穿透"></a>108. 什么是缓存穿透</h4><blockquote><p>大量查询不到的数据的请求落到后端数据库， 数据库压力增大</p><p>由于大量缓存查不到就去数据库取， 数据库也没有要查的数据</p><p>解决： 对没查到返回为None的数据也缓存；插入数据时删除相应缓存， 或者设置较短的超时时间</p></blockquote><h4 id="109-什么是缓存击穿？"><a href="#109-什么是缓存击穿？" class="headerlink" title="109. 什么是缓存击穿？"></a>109. 什么是缓存击穿？</h4><blockquote><p>某些非常热点的数据 key 过期， 大量请求打到后端数据库</p><p>由于热点数据key失效导致</p><p>解决： 分布式锁；异步后台更新， 后台任务争对过期的key自动刷新</p></blockquote><h4 id="110-什么是缓存雪崩"><a href="#110-什么是缓存雪崩" class="headerlink" title="110. 什么是缓存雪崩"></a>110. 什么是缓存雪崩</h4><blockquote><p>缓存不可用或者大量缓存key同时失效， 大量请求直接打到数据库</p><p>解决：多级缓存， 不同级别的key设置不同的超时时间；随机超时， key的超时时间随机设置， 防止同时超时</p><p>架构层面解决： 提升系统可用性， 监控、报警完善</p></blockquote><h4 id="111-为什么mysql数据库的主键使用自增的整数比较好，-使用uuid可以吗，-如果是分布式系统下怎么生成数据库的自增id？"><a href="#111-为什么mysql数据库的主键使用自增的整数比较好，-使用uuid可以吗，-如果是分布式系统下怎么生成数据库的自增id？" class="headerlink" title="111. 为什么mysql数据库的主键使用自增的整数比较好， 使用uuid可以吗， 如果是分布式系统下怎么生成数据库的自增id？"></a>111. 为什么mysql数据库的主键使用自增的整数比较好， 使用uuid可以吗， 如果是分布式系统下怎么生成数据库的自增id？</h4><blockquote><p>b+tree工作原理推导出来的</p></blockquote><h4 id="112-基于-redis-便携代码实现一个简单的分布式锁"><a href="#112-基于-redis-便携代码实现一个简单的分布式锁" class="headerlink" title="112. 基于 redis 便携代码实现一个简单的分布式锁"></a>112. 基于 redis 便携代码实现一个简单的分布式锁</h4><blockquote><p>要求： 支持超时时间参数</p><p>如果 redis 单个节点宕机了， 如何处理， 还有其他业界的方案实现分布式锁吗</p></blockquote><h4 id="113-什么是WSGI，为什么需要WSGI"><a href="#113-什么是WSGI，为什么需要WSGI" class="headerlink" title="113. 什么是WSGI，为什么需要WSGI"></a>113. 什么是WSGI，为什么需要WSGI</h4><blockquote><p>Web Server Gateway Interface，描述了 web server 如何与 web 框架 交互， web框架如何处理请求</p><p>为了让任意的web 框架应用能够部署在任意 web 服务器上</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span></span></span><br></pre></td></tr></table></figure><h4 id="114-Django-vs-Flask-vs-Tornado"><a href="#114-Django-vs-Flask-vs-Tornado" class="headerlink" title="114. Django vs Flask vs Tornado"></a>114. Django vs Flask vs Tornado</h4><blockquote><p>Django 大而全， 内置 ORM ， Admin 等组件， 第三方插件较多</p><p>Flask: 微框架， 插件机制， 比较灵活， 过于灵活就导致代码结构太自由， 不利于工程维护</p><p>Tornado：异步支持的为框架和异步网络库，生态不完善</p></blockquote><h4 id="115-什么是MVC"><a href="#115-什么是MVC" class="headerlink" title="115. 什么是MVC"></a>115. 什么是MVC</h4><blockquote><p>model, view, controller， 解耦数据、展示和操作</p><p>model ==&gt; ORM（Object Relational Mapping） 对象关系映射， 用于实现业务对象与数据表中的字段映射， 常用的 ORM 库有： sqlalchemy， django ORM, Peewee</p><p>view ==&gt;  </p><p>controller： 接收请求参数调用模型和视图完成请求</p><p><img src="C:%5CUsers%5Carclv%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200412152404326.png" alt="image-20200412152404326"></p></blockquote><h4 id="116-为什么要使用ORM"><a href="#116-为什么要使用ORM" class="headerlink" title="116. 为什么要使用ORM"></a>116. 为什么要使用ORM</h4><blockquote><p>更加面向对象， 代码量更少， 灵活性高， 提升开发效率</p></blockquote><h4 id="117-常见的web安全问题有哪些"><a href="#117-常见的web安全问题有哪些" class="headerlink" title="117. 常见的web安全问题有哪些"></a>117. 常见的web安全问题有哪些</h4><blockquote><p>sql注入, xss（跨站脚本攻击）, csrf（跨站请求伪造）</p></blockquote><h4 id="118-sql注入的原理，-如何防范"><a href="#118-sql注入的原理，-如何防范" class="headerlink" title="118. sql注入的原理， 如何防范"></a>118. sql注入的原理， 如何防范</h4><blockquote><p>通过构造特殊的输入参数传入web应用， 导致后端执行了恶意sql</p><p>有哪些恶意sql呢：</p><ol><li>利用sql ‘–’ 表示注释的语法让部分sql语句失效</li></ol><p>容易造成sql注入隐患的编码方式： 对不受信任的输入没有进行输入过滤， 直接动态拼接sql</p><p>防范：</p><ol><li>通过sqlmap， SQLninja等工具检测网站的sql注入漏洞</li><li>永远不要相信用户的任何输入<ol><li>对输入参数做好检查（类型和范围）；过滤和转义特殊字符</li><li>不要直接拼接sql， 使用ORM可以大大降低sql注入风险</li><li>数据库层做好权限管理配置； 不要明文存储敏感信息</li></ol></li></ol></blockquote><h4 id="119-XSS攻击的原理，-如何防范"><a href="#119-XSS攻击的原理，-如何防范" class="headerlink" title="119. XSS攻击的原理， 如何防范"></a>119. XSS攻击的原理， 如何防范</h4><blockquote><p>恶意用户将代码植入到提供给其他用户使用的页面中， 未经转义的恶意代码输出到其他用户的浏览器并被执行</p><p>用户浏览页面的时候嵌入页面中的脚本会被执行， 攻击用户（比如获取cookie）</p><p>主要分为两类： 反射型（非持久型）， 存储型（持久型）</p><p>像评论区容易有这种问题</p><p>危害：</p></blockquote><h4 id="120-CSRF"><a href="#120-CSRF" class="headerlink" title="120. CSRF"></a>120. CSRF</h4><h4 id="121-什么是前后端分离，有哪些优点？"><a href="#121-什么是前后端分离，有哪些优点？" class="headerlink" title="121. 什么是前后端分离，有哪些优点？"></a>121. 什么是前后端分离，有哪些优点？</h4><blockquote><p>后端只负责提供数据结构， 不再渲染模板， 前端获取数据并呈现</p><p>优点：</p><ol><li>前后端解耦， 接口复用（前端和客户端公用接口）， 减少开发量</li><li>各司其职， 前后端同步开发， 提供工作效率， 定义好接口规范</li><li>有利于调试、测试和运维部署</li></ol><p>缺点：</p><p>不利于页面seo的优化</p></blockquote><h4 id="122-什么是restful？"><a href="#122-什么是restful？" class="headerlink" title="122. 什么是restful？"></a>122. 什么是restful？</h4><blockquote><p>restful = 表现层状态转移， 由HTTP协议的主要设计者 roy fielding 提出</p><p>包含概念: 资源 Resources、 表现层 Representation、状态转化 State Transfer</p><p>是一种以资源为中心的web软件架构风格， 可以用 Ajax 和 Restful web服务构建应用</p><p>资源： 使用 URI 指向的一个实体</p><p>表现层： 资源的表现形式， 比如图片、HTML文本、媒体格式等【或者说文本和二进制】</p><p>状态转化： GET/POST/PUT/DELETE HTTP 动词来操作资源， 实现资源状态的改变</p></blockquote><h4 id="123-Restful的准则"><a href="#123-Restful的准则" class="headerlink" title="123. Restful的准则"></a>123. Restful的准则</h4><blockquote><p>设计概念和准则</p><ol><li>所有事物抽象为资源（resource）， 资源对应唯一的标识（identifier）</li><li>资源通过接口进行操作实现状态转移， 操作本身是无状态的</li><li>对资源的操作不会改变资源的标识（如果执行删除操作呢？）</li></ol></blockquote><h4 id="124-什么是-Restful-API"><a href="#124-什么是-Restful-API" class="headerlink" title="124. 什么是 Restful API"></a>124. 什么是 Restful API</h4><blockquote><ol><li>通过 HTTP GET/POST/PUT/DELETE 实现资源的获取/新建/更新/删除，将资源状态转移跟数据库的增删改查结合到一起</li><li>一般使用json格式返回数据</li><li>一般web框架都有相应的插件支持restful API</li></ol></blockquote><h4 id="125-如何设计-RESTFUL-API"><a href="#125-如何设计-RESTFUL-API" class="headerlink" title="125. 如何设计 RESTFUL API"></a>125. 如何设计 RESTFUL API</h4><blockquote><p><img src="C:%5CUsers%5Carclv%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200412160725707.png" alt="image-20200412160725707"></p></blockquote><h4 id="126-什么是HTTPS"><a href="#126-什么是HTTPS" class="headerlink" title="126. 什么是HTTPS"></a>126. 什么是HTTPS</h4><blockquote><ol><li>HTTP 和 HTTPS 的区别</li><li>什么是对称加密和非对称加密</li><li>HTTPS 的通信过程是什么样的？</li></ol></blockquote><h4 id="127-什么是系统设计"><a href="#127-什么是系统设计" class="headerlink" title="127. 什么是系统设计"></a>127. 什么是系统设计</h4><blockquote><p>系统设计是一个定义系统架构、模块、接口和数据满足特定需求的过程</p><p>如 设计一个短网址服务、评论服务、feed流系统、抢红包系统、秒杀系统</p><p>微服务架构很多系统被按照业务拆分， 需要单独设计一个系统服务</p><p>系统设计的难点：</p><ol><li>需要具备相关领域、算法的经验，由一定的架构设计能力， 如 feed流 推拉模型</li><li>熟悉后端技术组件， 如消息队列， 缓存， 数据库，框架</li><li>具备文档撰写， 流程图绘制， 架构设计，编码实现等综合能力</li></ol><p>怎么答：</p><ol><li>系统设计的三大要素：使用场景和限制条件；数据存储设计；算法模块设计</li><li>围绕三个要素回答：<ol><li>搞清楚场景和使用条件</li><li>设计数据存储系统</li><li>设计算法相关模块</li></ol></li><li>如： 短网址<ol><li>短网址服务给谁用？内部使用还是对外提供公共服务-&gt;</li><li>用户估计由多少， 至少要能支撑多少用户？</li><li>估算并发qps： 峰值qps是多少， 平均 qps是多少</li><li>按需求设计数据表， 需要哪些字段， 使用什么类型， 数据增长规模</li><li>按照上面的一个设计， 应该选择什么样的数据库， 是否需要持久化， 使用关系型还是nosql</li><li>如何优化？如何设计索引， 是否需要使用缓存</li><li>程序=算法+数据结构；系统=服务+系统</li><li>需要哪些接口？接口如何设计？</li><li>使用什么算法或者模型？</li><li>不同实现方式之间的优劣对比， 如何取舍</li></ol></li></ol></blockquote><h4 id="128-系统如何进行扩展？如用户增多之后，-qps上来了，现有设计不再满足使用需求了，-要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了，-现有容量不够了）"><a href="#128-系统如何进行扩展？如用户增多之后，-qps上来了，现有设计不再满足使用需求了，-要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了，-现有容量不够了）" class="headerlink" title="128. 系统如何进行扩展？如用户增多之后， qps上来了，现有设计不再满足使用需求了， 要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了， 现有容量不够了）"></a>128. 系统如何进行扩展？如用户增多之后， qps上来了，现有设计不再满足使用需求了， 要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了， 现有容量不够了）</h4><h4 id="129-故障如何处理？单点失败，-多点失败，雪崩问题"><a href="#129-故障如何处理？单点失败，-多点失败，雪崩问题" class="headerlink" title="129. 故障如何处理？单点失败， 多点失败，雪崩问题"></a>129. 故障如何处理？单点失败， 多点失败，雪崩问题</h4><h4 id="130-设计一个短网址系统"><a href="#130-设计一个短网址系统" class="headerlink" title="130. 设计一个短网址系统"></a>130. 设计一个短网址系统</h4><blockquote><p>什么是短网址系统？包含哪些功能（接口）</p><p>短网址系统的存储设计？需要存储哪些字段？</p><p>如何设计算法生成短网址？</p><p>TintUrl Service:   bitly.com</p><p>把一个长网址转成短网址的服务</p><p>转换网址的后缀不超过7位</p><p>场景和限制：</p><p>提供给公司其他业务服务</p><p>功能： 一个长网址转成短网址并存储；根据短网址还原长url</p><p>要求短网址的后缀不超过7位</p><p>预估峰值插入请求数量级： 数百；查询请求数量级：数千</p><p>数据存储设计：</p><p>根据需求设计数据库存储设计： mysql即可满足</p><p>id，短网址token， 原网址，创建时间</p><p>创建索引： token</p><p>算法实现设计：</p><p>两个API： long2short_url, short2long_url</p><p>long2short 的方法： 1. md5 长度过长； 2. 类似于62进制的数字， 将十进制ID转换成62进制的短网址 –&gt; 进制转换问题 也叫递增序列算法</p><p>需要一个全局计数器来得到自增id（通过redis 的 incr维护）</p><p>// python中相关的函数： divmod， 返回商和余数</p></blockquote><h4 id="131-设计一个秒杀系统"><a href="#131-设计一个秒杀系统" class="headerlink" title="131. 设计一个秒杀系统"></a>131. 设计一个秒杀系统</h4><blockquote><p>难点： 如何应对高并发的用户请求</p><p>秒杀系统涉及到哪些后端组件？（消息队列消峰， 如何实现削减库存？）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-python语言相比其他语言的优点和缺点&quot;&gt;&lt;a href=&quot;#1-python语言相比其他语言的优点和缺点&quot; class=&quot;headerlink&quot; title=&quot;1. python语言相比其他语言的优点和缺点&quot;&gt;&lt;/a&gt;1. python语言相比其他语言的优点和缺点&lt;/h4&gt;&lt;p&gt;编码结构风格： 去除花括号、分号等符号， 通过强制缩进来区分来标识代码块。这一点赞赏的人很多，排斥的人也很多， 当嵌套层级较深时， 代码段的排版可读性会下降；&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Q&amp;A] 操作系统知识·其一</title>
    <link href="http://yoursite.com/2020/05/08/Q-A-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%C2%B7%E5%85%B6%E4%B8%80/"/>
    <id>http://yoursite.com/2020/05/08/Q-A-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%C2%B7%E5%85%B6%E4%B8%80/</id>
    <published>2020-05-07T16:32:28.000Z</published>
    <updated>2020-05-08T14:03:11.523Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>[Q&amp;A] 网络协议</title>
    <link href="http://yoursite.com/2020/05/08/Q-A-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/05/08/Q-A-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-05-07T16:31:51.000Z</published>
    <updated>2020-05-08T13:05:33.855Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[Q&amp;A] Python 语言知识·其二</title>
    <link href="http://yoursite.com/2020/05/08/Q-A-Python-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%C2%B7%E5%85%B6%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/05/08/Q-A-Python-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%C2%B7%E5%85%B6%E4%BA%8C/</id>
    <published>2020-05-07T16:31:24.000Z</published>
    <updated>2020-05-08T13:05:33.854Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[Q&amp;A] Python 语言知识·其一</title>
    <link href="http://yoursite.com/2020/05/08/Q-A-Python-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%C2%B7%E5%85%B6%E4%B8%80/"/>
    <id>http://yoursite.com/2020/05/08/Q-A-Python-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%C2%B7%E5%85%B6%E4%B8%80/</id>
    <published>2020-05-07T16:30:38.000Z</published>
    <updated>2020-05-08T13:05:33.853Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
