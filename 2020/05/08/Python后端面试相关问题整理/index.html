<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Python后端面试相关问题整理 |
    
    小夜灯</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小夜灯" type="application/atom+xml">
</head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-Python后端面试相关问题整理" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      Python后端面试相关问题整理
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/08/Python%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-05-07T16:32:53.000Z" itemprop="datePublished">2020-05-08</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <blockquote>
<p>本文将整理 Python后端面试相关的比较重要的问题， 并列出主要相关知识点， 作为回答问题时的思路参考。</p>
</blockquote>
<a id="more"></a>

<h2 id="Part-1-Python-语言知识相关问题"><a href="#Part-1-Python-语言知识相关问题" class="headerlink" title="Part 1: Python 语言知识相关问题"></a>Part 1: Python 语言知识相关问题</h2><p><strong>本节内容梳理 python 编程语言相关的知识点， 主要包括语言特性、设计模式和具体领域编程相关的问题（主要是 网络编程， 重要知识点为 socket 编程相关问题、并行并发相关的问题以及几个主流框架的理解问题）</strong></p>
<h3 id="1-1-Python-语言相比其他语言的优点和缺点"><a href="#1-1-Python-语言相比其他语言的优点和缺点" class="headerlink" title="1.1 Python 语言相比其他语言的优点和缺点"></a>1.1 Python 语言相比其他语言的优点和缺点</h3><blockquote>
<p>总结，在语言的抉择上，我们可以从类型系统的静态检查，动态检查，检查范围及类型是否可变这几个维度来考虑，<strong>在开发效率，执行效率及安全性之间做权衡</strong>。无类型的语言可以很安全，但是可维护性差，基本被排除在系统开发之外。_&lt;出自参考文章1&gt;_</p>
<p>参考文章： </p>
<ol>
<li><a href="https://www.techug.com/post/choose-a-programming-language.html" target="_blank" rel="noopener">https://www.techug.com/post/choose-a-programming-language.html</a> </li>
<li><a href="https://blog.teamtreehouse.com/choose-programming-language" target="_blank" rel="noopener">https://blog.teamtreehouse.com/choose-programming-language</a> </li>
<li><a href="https://stackoverflow.com/questions/8070181/how-to-choose-a-programming-paradigm-to-work-with" target="_blank" rel="noopener">https://stackoverflow.com/questions/8070181/how-to-choose-a-programming-paradigm-to-work-with</a> </li>
<li><a href="https://zhuanlan.zhihu.com/p/34200056" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34200056</a> </li>
</ol>
</blockquote>
<p>语言的优势劣势都是具体到编程任务而言的，不同的业务场景、编程任务、开发平台，甚至历史遗留因素以及用工环境都可能会影响开发语言的选择。比如web开发， 国内java开发人员人数较多， 开发实践成熟， 因此java可以说是最佳的首选语言。但是如果是功能相对较简单、用户数不大的内部web项目， 只能投入较少的人力， 这个时候就会考虑用 python 的相关web框架来搭建。从实际落地的角度来讲， 有些时候会考虑当前团队的技术栈情况， 优先考虑团队熟悉的语言。</p>
<p>编程语言选型时可以先从业务角度遴选出可选编程语言， 然后再从技术角度确定使用哪种编程语言。</p>
<p>以下从技术角度和业务角度来看开发语言选型的问题， 从这个角度， 更加客观的看待不同语言的优劣。</p>
<p>从技术的角度考量三个大维度（简化优先考量）： 类型系统、语法、编程范式支持。 </p>
<p><strong>语言技术选型考量表：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注： </span><br><span class="line">A. 所有语言都支持动态检查（运行时检查）， 因此<span class="code">`静态[动态]检查`</span>一栏实际是考量是否有静态检查机制。</span><br><span class="line">B. 这里说明下强类型和弱类型的定义，强类型是指一旦被指定类型， 不可变， 弱类型则可变（包括隐式和显式两种）。</span><br><span class="line">C. 编程范式缩写：</span><br><span class="line"><span class="code">	IP：指令式编程， 代表——汇编</span></span><br><span class="line"><span class="code">	SP：结构化编程，通过for、while等此类结构化的代码来进行流程控制</span></span><br><span class="line"><span class="code">	PP：过程是编程，特点是函数封装， 函数调用</span></span><br><span class="line"><span class="code">	OOP：面向对象编程， 将对数据和操作封装在一起</span></span><br><span class="line"><span class="code">	FP：函数式编程，特点——隐藏SP逻辑（尤其是控制流程）， 例 map(function, array)</span></span><br><span class="line"><span class="code">	MP：元编程， 元编程是一种可以将程序当作数据来操作的技术，元编程能够读取，生成，分析或转换其他的程序代码，甚至可以在运行时修改自身 。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语言</th>
<th>类型系统</th>
<th>静态[动态]检查</th>
<th>强类型检测</th>
<th>弱/强类型</th>
<th>静态/动态类型</th>
<th>实现的类型理论</th>
<th>编程范式支持</th>
</tr>
</thead>
<tbody><tr>
<td>java</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>强类型</td>
<td>静态类型</td>
<td>泛型/多态/重载</td>
<td>IP,<br />SP,<br />PP,<br />OOP,<br />FP,<br />MP</td>
</tr>
<tr>
<td>python</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>弱类型</td>
<td>动态类型</td>
<td>鸭子类型/多态/重载</td>
<td>IP,<br />PP,<br />OOP,<br />FP,<br />MP</td>
</tr>
<tr>
<td>GO</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>强类型</td>
<td>静态类型</td>
<td>鸭子类型</td>
<td>IP,<br />PP,<br />MP</td>
</tr>
</tbody></table>
<p><strong>语言业务场景选型参考：</strong></p>
<table>
<thead>
<tr>
<th>语言</th>
<th>优势业务场景</th>
</tr>
</thead>
<tbody><tr>
<td>C / C++</td>
<td>操作系统、软件、库</td>
</tr>
<tr>
<td>JAVA</td>
<td>跨平台桌面应用程序、web应用程序服务端、android</td>
</tr>
<tr>
<td>swift</td>
<td>MAC OS X 应用程序、iOS应用程序</td>
</tr>
<tr>
<td>C#</td>
<td>WINDOWS桌面应用程序、MS、web应用程序</td>
</tr>
<tr>
<td>PHP</td>
<td>web应用程序服务端</td>
</tr>
<tr>
<td>Perl</td>
<td>一般脚本、字符串处理</td>
</tr>
<tr>
<td>Python</td>
<td>通用脚本、web应用程序服务端、数学和科学应用程序、Linux桌面应用程序</td>
</tr>
<tr>
<td>Ruby</td>
<td>通用脚本、web应用程序服务端</td>
</tr>
<tr>
<td>JavaScript</td>
<td>web应用程序客户端</td>
</tr>
</tbody></table>
<h3 id="1-2-什么是鸭子类型"><a href="#1-2-什么是鸭子类型" class="headerlink" title="1.2 什么是鸭子类型"></a>1.2 什么是鸭子类型</h3><p>鸭子类型是一种类型理论， 这个理论更加关注对象的外部行为而非内部结构。鸭子类型也是多态的一种形式，在这种形式中， 不管对象属于哪个类， 也不管声明的具体接口是什么， 只要对象实现了相应的方法， 函数就可以在对象上执行。</p>
<p>鸭子类型并非python独有， 而是python的类型系统实践了这一类型理论。GoLang同样支持鸭子类型。对于python而言， 函数使用传入对象时， 只要对象拥有相应的属性或方法， 程序就可以运行；对于GoLang而言， 只要传入的参数（结构体）有拥有声明的接口， 程序就可以通过编译。</p>
<p>python 基本上可以说处处体现了鸭子类型的运用。全部的类基本都默认继承了 object 的 __str__ 方法， 所有全部对象都可以作为 print 函数的参数； 任何实现了__getitem__的对象都支持索引语法。</p>
<h3 id="1-3-什么是猴子补丁技术？什么场景下可以使用猴子补丁？有哪些案例？"><a href="#1-3-什么是猴子补丁技术？什么场景下可以使用猴子补丁？有哪些案例？" class="headerlink" title="1.3 什么是猴子补丁技术？什么场景下可以使用猴子补丁？有哪些案例？"></a>1.3 什么是猴子补丁技术？什么场景下可以使用猴子补丁？有哪些案例？</h3><p>猴子补丁技术本质上是利用动态编程语言可以在程序运行时修改程序结构这一特点， 在运行时修改对象的属性和方法。gevent在这方面的运用比较多。不鼓励多用。</p>
<h3 id="1-4-什么是自省（内省）？有什么用处？"><a href="#1-4-什么是自省（内省）？有什么用处？" class="headerlink" title="1.4 什么是自省（内省）？有什么用处？"></a>1.4 什么是自省（内省）？有什么用处？</h3><blockquote>
<p>参考资料： <a href="https://www.bnmetrics.com/blog/introspection-reflection-in-python" target="_blank" rel="noopener">https://www.bnmetrics.com/blog/introspection-reflection-in-python</a> </p>
</blockquote>
<p>自省和反射是不同的。python同时有自省和反射的概念。通常说自省， 指的是只用于检查对象的这一行为。而反射既可以检查对象， 又可以修改对象。</p>
<p>python中自省的方法主要有以下几个：</p>
<ul>
<li>hasattr</li>
<li>getattr</li>
<li>setattr(需确认是否属于反射的范畴)</li>
<li>delattr</li>
<li>dir</li>
<li>isinstance</li>
<li>type</li>
<li>callable</li>
<li>inspect 库提供的方法</li>
</ul>
<h3 id="1-5-Python-中有哪些语法糖？有哪些常用的语法糖？"><a href="#1-5-Python-中有哪些语法糖？有哪些常用的语法糖？" class="headerlink" title="1.5 Python 中有哪些语法糖？有哪些常用的语法糖？"></a>1.5 Python 中有哪些语法糖？有哪些常用的语法糖？</h3><blockquote>
<p>在计算机科学中， 语法糖是指编程语言中可以更容易表达一个操作的语法， 它可以使程序员更加容易去使用这门语言： 操作可以变得更加清晰、方便， 或者更加符合程序员的编程习惯。</p>
</blockquote>
<p>python提供的语法糖有 索引、运算符、列表推导式、生成器推导式等等。</p>
<h3 id="1-6-Python3-相比-python2-有哪些重要的变化？具体有什么影响？"><a href="#1-6-Python3-相比-python2-有哪些重要的变化？具体有什么影响？" class="headerlink" title="1.6 Python3 相比 python2 有哪些重要的变化？具体有什么影响？"></a>1.6 Python3 相比 python2 有哪些重要的变化？具体有什么影响？</h3><ol>
<li>较重大的改变：<ol>
<li>print 从语句变成函数</li>
<li>编码问题， 3.x 默认使用 unicode， 取消了原来的 unicode 对象， str对象就相当于原来的unicode， 而原来的 str 在 3.x 中是bytes。</li>
<li>除法变化， 3.x 的除法返回浮点数</li>
<li>增加了类型注解（type hint）的支持， 帮助ide实现类型检查（也只是作为提醒而已）</li>
<li>优化super()方法， 方便直接调用父类函数</li>
<li>高级解包操作： a, b, *res = range(10)</li>
<li>增加 keyword only arguments 限定关键字参数</li>
<li>chained exception, python3 中重新抛出异常不会丢失堆栈信息</li>
</ol>
</li>
<li>新增特性：<ol>
<li>yield from 链接子生成器</li>
<li>asynico内置库， async/await 原生协程支持异步编程</li>
<li>新的内置库 enum， mock， asyncio， ipaddress， concurrent.future 等</li>
<li>生成的 pyc 文件统一放到 __pycache__</li>
<li>性能优化等</li>
</ol>
</li>
</ol>
<h3 id="1-7-如何将-Python2-的代码迁移到-Python3？"><a href="#1-7-如何将-Python2-的代码迁移到-Python3？" class="headerlink" title="1.7 如何将 Python2 的代码迁移到 Python3？"></a>1.7 如何将 Python2 的代码迁移到 Python3？</h3><h3 id="1-8-为什么说函数是一等公民？"><a href="#1-8-为什么说函数是一等公民？" class="headerlink" title="1.8 为什么说函数是一等公民？"></a>1.8 为什么说函数是一等公民？</h3><p>一等对象满足以下条件：</p>
<ul>
<li>在运行时创建</li>
<li>能赋值给变量或数据结构中的元素</li>
<li>能作为参数传给函数</li>
<li>能作为函数的返回结果</li>
</ul>
<h3 id="1-9-函数和方法的区别？"><a href="#1-9-函数和方法的区别？" class="headerlink" title="1.9 函数和方法的区别？"></a>1.9 函数和方法的区别？</h3><p>函数本质上是 FunctionObject， 而方法是 PyMethodObject。从声明的位置看，函数的命名空间是在模块上， 而方法的命名空间是实例。从实现的协议接口看， 函数相较方法拥有以下几个属性：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>__annotations__</td>
<td>dict</td>
<td>参数和返回值的注解</td>
</tr>
<tr>
<td>__call__</td>
<td>method-wrapper</td>
<td>实现 () 运算符；即可调用对象协议</td>
</tr>
<tr>
<td>__closure__</td>
<td>tuple</td>
<td>函数闭包， 即自由变量的绑定</td>
</tr>
<tr>
<td>__code__</td>
<td>code</td>
<td>编译成字节码的函数元数据和函数定义体</td>
</tr>
<tr>
<td>__defaults__</td>
<td>tuple</td>
<td>形式参数的默认值</td>
</tr>
<tr>
<td>__get__</td>
<td>method-wrapper</td>
<td>实现只读描述符协议</td>
</tr>
<tr>
<td>__globals__</td>
<td>dict</td>
<td>函数所在模块中的全局变量</td>
</tr>
<tr>
<td>__kwdefaults__</td>
<td>dict</td>
<td>仅限关键字形式参数的默认值</td>
</tr>
<tr>
<td>__name__</td>
<td>str</td>
<td>函数名称</td>
</tr>
</tbody></table>
<p>实例方法会在实例初始化的时候被绑定到实例对象上， 这个方法本质上是method对象， 但事实上解释器生成了方法所对应的function对象， 挂在 __func__这个命名空间上。而方法声明其实是类命名空间下的 function 对象。</p>
<h3 id="1-10-函数的传参过程是怎么样的？实参跟形参有什么区别？"><a href="#1-10-函数的传参过程是怎么样的？实参跟形参有什么区别？" class="headerlink" title="1.10 函数的传参过程是怎么样的？实参跟形参有什么区别？"></a>1.10 函数的传参过程是怎么样的？实参跟形参有什么区别？</h3><blockquote>
<p>参考资料：</p>
<p>《python学习手册》- 18章 - 参数</p>
</blockquote>
<p>python 的传参并不是引用传递， 也不是值传递， 而是传递“指针”。python 的参数传递是通过自动将对象赋值给本地变量名来实现的， 也就是说， 传参对对象创建了一个新的引用， 而在 Cython中， 引用是以指针的形式进行传递的。这也意味着传参过程中， 并没有对对象进行拷贝。</p>
<p>在函数运行时， 形参是一个新的、本地的变量名，这个变量名实在函数的本地作用域内的。在函数调用时， 形参跟实参都引用同一个对象。</p>
<h3 id="1-11-参数类型有哪些？"><a href="#1-11-参数类型有哪些？" class="headerlink" title="1.11 参数类型有哪些？"></a>1.11 参数类型有哪些？</h3><ul>
<li>位置参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>可变位置参数</li>
<li>可变关键字参数</li>
<li>仅限关键字参数</li>
</ul>
<h3 id="1-12-传参时有哪些要注意的问题？"><a href="#1-12-传参时有哪些要注意的问题？" class="headerlink" title="1.12 传参时有哪些要注意的问题？"></a>1.12 传参时有哪些要注意的问题？</h3><ol>
<li>函数接收可变参数时， 函数中要谨慎对可变参数的修改；</li>
<li>参数默认值如果为可变参数的， 不要在形参处做初始化，应该使用None作为默认参数， 然后在函数内部作判断和初始化。</li>
</ol>
<h3 id="1-13-python中有哪些可变对象？哪些不可变对象？"><a href="#1-13-python中有哪些可变对象？哪些不可变对象？" class="headerlink" title="1.13 python中有哪些可变对象？哪些不可变对象？"></a>1.13 python中有哪些可变对象？哪些不可变对象？</h3><p>可变对象： list, bytearray, array.array, collections.deque, memoryview,  dict, set</p>
<p>不可变对象： tuple, str, bytes,  bool, frozenset, 数值类型</p>
<p>元组是相对不可变的对象， 元组存储的是对象的引用， 当元组中的存在可变对象的引用时， 引用不可变， 但是引用的对象时可变的。</p>
<h3 id="1-14-生成器和迭代器有什么区别？"><a href="#1-14-生成器和迭代器有什么区别？" class="headerlink" title="1.14 生成器和迭代器有什么区别？"></a>1.14 生成器和迭代器有什么区别？</h3><p>迭代器是生成器的一种。 迭代器与可迭代对象又是不同的对象类型.</p>
<!-- TODO: 从接口协议的角度说明迭代器需要实现哪些协议接口，可迭代对象需要实现哪些协议接口， 生成器需要实现哪些接口。三种对象的实现方式。 -->

<h3 id="1-15-如何实现协程？"><a href="#1-15-如何实现协程？" class="headerlink" title="1.15 如何实现协程？"></a>1.15 如何实现协程？</h3><!-- TODO: 说明协程的实现方式 -->

<h3 id="1-16-python中如何进行异常处理？如何自定义一个异常类？"><a href="#1-16-python中如何进行异常处理？如何自定义一个异常类？" class="headerlink" title="1.16 python中如何进行异常处理？如何自定义一个异常类？"></a>1.16 python中如何进行异常处理？如何自定义一个异常类？</h3><p>python使用 try … except … finally … 捕获异常。 自定义异常类通常继承自 Exception 类，最简单的继承方式就是 声明一个类继承自 Exception， 不需要新增属性和方法。</p>
<h3 id="1-17-什么时候需要捕获异常？"><a href="#1-17-什么时候需要捕获异常？" class="headerlink" title="1.17 什么时候需要捕获异常？"></a>1.17 什么时候需要捕获异常？</h3><!-- TODO: 总结下需要捕获异常的场景 -->

<h3 id="1-18-什么是单元测试？python中如何进行单元测试？"><a href="#1-18-什么是单元测试？python中如何进行单元测试？" class="headerlink" title="1.18 什么是单元测试？python中如何进行单元测试？"></a>1.18 什么是单元测试？python中如何进行单元测试？</h3><h3 id="1-19-什么是浅拷贝？什么是深拷贝？如何实现深拷贝？"><a href="#1-19-什么是浅拷贝？什么是深拷贝？如何实现深拷贝？" class="headerlink" title="1.19 什么是浅拷贝？什么是深拷贝？如何实现深拷贝？"></a>1.19 什么是浅拷贝？什么是深拷贝？如何实现深拷贝？</h3><!-- TODO: 网上的文章对深拷贝的实现都是单独讨论对列表和字典进行深拷贝， 但如果把深拷贝的范围扩展到自定义的对象呢？python的 deepcopy 考虑了很多东西， 而且必要实现一些接口协议才能够进行深拷贝。 -->

<h3 id="1-20-python如何管理依赖？"><a href="#1-20-python如何管理依赖？" class="headerlink" title="1.20 python如何管理依赖？"></a>1.20 python如何管理依赖？</h3><p>依赖管理历史：</p>
<h3 id="1-21-如何分析python代码的性能？如何优化python的性能？"><a href="#1-21-如何分析python代码的性能？如何优化python的性能？" class="headerlink" title="1.21 如何分析python代码的性能？如何优化python的性能？"></a>1.21 如何分析python代码的性能？如何优化python的性能？</h3><h3 id="1-22-什么是GIL？如何规避GIL的影响？"><a href="#1-22-什么是GIL？如何规避GIL的影响？" class="headerlink" title="1.22 什么是GIL？如何规避GIL的影响？"></a>1.22 什么是GIL？如何规避GIL的影响？</h3><p>GIL是仅在cython解释器版本才存在的， 通过GIL， python解释器保证多线程情况下， 同一时间， 内核只执行一条语句。规避手段见 python cookbook。</p>
<p>GIL存在的愿意是因为解释器的 C 语言实现部分在完全并行执行时并不是线程安全的。因此在设计上， 解释器被一个全局解释器锁保护着， 它确保任何时候都只有一个 Python 线程执行。 GIL最大的问题就是 Python 的多线程程序并不能利用多核 CPU 的优势（比如一个使用了多线程的计算密集型程序只会在一个单CPU上面运行）， 所以 GIL 对于 IO 密集型的程序是没有多大影响的。解决 GIL 缺陷的途径有两种： 1. 使用进程池；2. 使用 C 扩展编程技术，使用 ctypes 调用 C 时会自动释放GIL。</p>
<h3 id="1-23-python有哪些内置数据结构？"><a href="#1-23-python有哪些内置数据结构？" class="headerlink" title="1.23 python有哪些内置数据结构？"></a>1.23 python有哪些内置数据结构？</h3><!-- TODO: 抄一下 -->

<h3 id="1-24-列表和元组有什么区别？"><a href="#1-24-列表和元组有什么区别？" class="headerlink" title="1.24 列表和元组有什么区别？"></a>1.24 列表和元组有什么区别？</h3><!-- 数据结构的角度（数据存储和操作）、使用场景的角度 -->

<h3 id="1-25-python的字典是如何实现的？"><a href="#1-25-python的字典是如何实现的？" class="headerlink" title="1.25 python的字典是如何实现的？"></a>1.25 python的字典是如何实现的？</h3><blockquote>
<p>参考资料：</p>
<p>《流畅的python》-3章</p>
</blockquote>
<p>python字典的底层实现是散列表。</p>
<h3 id="1-26-什么是随机访问？"><a href="#1-26-什么是随机访问？" class="headerlink" title="1.26 什么是随机访问？"></a>1.26 什么是随机访问？</h3><p>数组中的元素存储在一段连续内存中， 访问数组中任意元素都可以通过下标计算直接得到元素的内存地址， 访问耗时与元素的数组中所处的位置无关。与之相对的是链表的顺序访问。</p>
<h3 id="1-27-内置数据结构常用操作的时间复杂度是多少？"><a href="#1-27-内置数据结构常用操作的时间复杂度是多少？" class="headerlink" title="1.27 内置数据结构常用操作的时间复杂度是多少？"></a>1.27 内置数据结构常用操作的时间复杂度是多少？</h3><!-- TODO: 列个表-->

<h3 id="1-28-什么是闭包？"><a href="#1-28-什么是闭包？" class="headerlink" title="1.28 什么是闭包？"></a>1.28 什么是闭包？</h3><p>在一个内部函数里， 对在外部作用域（不在全局作用域）的变量进行引用， 那么这个内部函数就是闭包（closure）。在闭包中操作引用了不可变对象的自由变量时， 如果涉及到对自由变量的重新赋值， 在python中， 要在闭包内 用 nonlocal 关键字先声明这个自由变量， 否则赋值时， 该变量会被视为本地变量；而在python2中， 需要将该对象放入可变对象中。</p>
<h3 id="1-29-实现一个装饰器"><a href="#1-29-实现一个装饰器" class="headerlink" title="1.29 实现一个装饰器"></a>1.29 实现一个装饰器</h3><h3 id="1-30-实现一个装饰器工厂"><a href="#1-30-实现一个装饰器工厂" class="headerlink" title="1.30 实现一个装饰器工厂"></a>1.30 实现一个装饰器工厂</h3><h3 id="1-31-装饰器通常用来实现什么功能？"><a href="#1-31-装饰器通常用来实现什么功能？" class="headerlink" title="1.31 装饰器通常用来实现什么功能？"></a>1.31 装饰器通常用来实现什么功能？</h3><h3 id="1-32-什么叫高阶函数？python中有哪些高阶函数？"><a href="#1-32-什么叫高阶函数？python中有哪些高阶函数？" class="headerlink" title="1.32 什么叫高阶函数？python中有哪些高阶函数？"></a>1.32 什么叫高阶函数？python中有哪些高阶函数？</h3><!-- TODO: 其实实践了FP范式 -->

<h3 id="1-33-什么是面向对象？"><a href="#1-33-什么是面向对象？" class="headerlink" title="1.33 什么是面向对象？"></a>1.33 什么是面向对象？</h3><!-- TODO: 这种简单的问题就是比较烦人， 不知道从那个点切入去讲， 查一查 -->

<h3 id="1-34-面向对象有哪些特征？"><a href="#1-34-面向对象有哪些特征？" class="headerlink" title="1.34 面向对象有哪些特征？"></a>1.34 面向对象有哪些特征？</h3><!-- TODO: 封装、继承、多态 -->

<h3 id="1-35-什么是元编程？有哪些案例？"><a href="#1-35-什么是元编程？有哪些案例？" class="headerlink" title="1.35 什么是元编程？有哪些案例？"></a>1.35 什么是元编程？有哪些案例？</h3><!-- TODO: 流畅的python -->

<h3 id="1-36-什么是类元编程？"><a href="#1-36-什么是类元编程？" class="headerlink" title="1.36 什么是类元编程？"></a>1.36 什么是类元编程？</h3><!-- TODO: 流畅的python -->

<h3 id="1-37-类是谁的对象？type是谁的对象？"><a href="#1-37-类是谁的对象？type是谁的对象？" class="headerlink" title="1.37 类是谁的对象？type是谁的对象？"></a>1.37 类是谁的对象？type是谁的对象？</h3><!-- TODO: python 继承树，类是type的对象， type是自己的对象(实际上 type 也继承了object， 所以 python中， 一切皆'对象' 也有这个设计层面的含义) -->

<h3 id="1-38-python的垃圾回收机制是如何工作的？"><a href="#1-38-python的垃圾回收机制是如何工作的？" class="headerlink" title="1.38 python的垃圾回收机制是如何工作的？"></a>1.38 python的垃圾回收机制是如何工作的？</h3><p>python的GC机制是以引用计数为主， 标志清除和分代回收为辅的策略。</p>
<p>python中的每一个对象都维护一个引用计数， 当该对象的引用数为 0 时， 该对象立即被回收。可以通过以下方式获取对象的引用次数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Test()</span><br><span class="line">print(sys.getrefcount(a))  <span class="comment"># 函数调用时， 将对象赋值给了形参， 会增加一次引用</span></span><br></pre></td></tr></table></figure>

<p>引用计数可以处理大部分对象的回收， 但是对于循环引用的对象， 它们的计数引用总会大于0。</p>
<p>为了解决对象循环引用的问题， python中引入了标记清除和分代回收两种机制。</p>
<p>标记清除算法时一种基于追踪回收技术实现的GC算法， 这个算法分 <strong>两个</strong> 阶段， 第一个阶段是标记， GC会把所有的活动对象打上标记， 第二阶段是把那些没有标记的对象 <strong>非活动对象</strong> 进行回收。对象之间通过引用连在一起， 构成一个有向图， 对象构成这个图的节点， 引用构成有向边。从根节点（全局变量、调用栈、寄存器）出发， 沿着有向边遍历对象， 可达的对象标记为活动对象， 不可达的对象就是要被清除的非活动对象。</p>
<p>为了标记活动对象， 解释器必须顺序扫描整个堆内存， 哪怕只剩下小部分活动对象也要扫描所有对象，而且什么时候扫描并不是用户控制的。</p>
<p>为了解决这个缺陷， 又引入了分代回收。分代回收是一种空间换事件的操作方式。python将内存根据对象的存活时间划分为不同的集合， 每个集合称为一个代， python将内存分为3代， 对应3个链表， 他们的垃圾收集频率与对象的存活时间增大而减小。新创建的对象都被分配在年轻代， 年轻代链表填满时， GC就会被触发， 释放可回收的， 不可回收的移到中年代去；中年代GC的触发以此类比。</p>
<h3 id="1-39-什么是工厂模式？核心思想是什么？什么场景下可以使用工厂模式？"><a href="#1-39-什么是工厂模式？核心思想是什么？什么场景下可以使用工厂模式？" class="headerlink" title="1.39 什么是工厂模式？核心思想是什么？什么场景下可以使用工厂模式？"></a>1.39 什么是工厂模式？核心思想是什么？什么场景下可以使用工厂模式？</h3><!-- TODO: 重构与模式一书 -->

<h3 id="1-40-什么是构造模式？"><a href="#1-40-什么是构造模式？" class="headerlink" title="1.40 什么是构造模式？"></a>1.40 什么是构造模式？</h3><h3 id="1-41-什么是原型模式？"><a href="#1-41-什么是原型模式？" class="headerlink" title="1.41 什么是原型模式？"></a>1.41 什么是原型模式？</h3><h3 id="1-42-什么是单例模式？"><a href="#1-42-什么是单例模式？" class="headerlink" title="1.42 什么是单例模式？"></a>1.42 什么是单例模式？</h3><h3 id="1-43-什么是装饰器模式？"><a href="#1-43-什么是装饰器模式？" class="headerlink" title="1.43 什么是装饰器模式？"></a>1.43 什么是装饰器模式？</h3><h3 id="1-44-什么是代理模式？"><a href="#1-44-什么是代理模式？" class="headerlink" title="1.44 什么是代理模式？"></a>1.44 什么是代理模式？</h3><h3 id="1-45-什么是适配器模式？"><a href="#1-45-什么是适配器模式？" class="headerlink" title="1.45 什么是适配器模式？"></a>1.45 什么是适配器模式？</h3><h3 id="1-46-什么是外观模式？"><a href="#1-46-什么是外观模式？" class="headerlink" title="1.46 什么是外观模式？"></a>1.46 什么是外观模式？</h3><h3 id="1-47-什么是享元模式？"><a href="#1-47-什么是享元模式？" class="headerlink" title="1.47 什么是享元模式？"></a>1.47 什么是享元模式？</h3><h3 id="1-48-什么是MVC模式？"><a href="#1-48-什么是MVC模式？" class="headerlink" title="1.48 什么是MVC模式？"></a>1.48 什么是MVC模式？</h3><h3 id="1-49-什么是惰性计算模式"><a href="#1-49-什么是惰性计算模式" class="headerlink" title="1.49 什么是惰性计算模式"></a>1.49 什么是惰性计算模式</h3><h3 id="1-50-什么是迭代器模式？"><a href="#1-50-什么是迭代器模式？" class="headerlink" title="1.50 什么是迭代器模式？"></a>1.50 什么是迭代器模式？</h3><h3 id="1-51-什么是观察者模式？"><a href="#1-51-什么是观察者模式？" class="headerlink" title="1.51 什么是观察者模式？"></a>1.51 什么是观察者模式？</h3><h3 id="1-52-什么是策略模式？"><a href="#1-52-什么是策略模式？" class="headerlink" title="1.52 什么是策略模式？"></a>1.52 什么是策略模式？</h3><h3 id="1-53-简述TCP编程的原理"><a href="#1-53-简述TCP编程的原理" class="headerlink" title="1.53 简述TCP编程的原理"></a>1.53 简述TCP编程的原理</h3><!-- TODO: 重点准备 -->

<h3 id="1-54-如何使用-socket-编程发送-HTTP-请求？"><a href="#1-54-如何使用-socket-编程发送-HTTP-请求？" class="headerlink" title="1.54 如何使用 socket 编程发送 HTTP 请求？"></a>1.54 如何使用 socket 编程发送 HTTP 请求？</h3><!-- TODO: 重点准备， 系统层面的 socket api + HTTP 协议结构 -->

<h3 id="1-55-什么是阻塞socket？什么是非阻塞socket？"><a href="#1-55-什么是阻塞socket？什么是非阻塞socket？" class="headerlink" title="1.55 什么是阻塞socket？什么是非阻塞socket？"></a>1.55 什么是阻塞socket？什么是非阻塞socket？</h3><!-- TODO: 重点准备， 这个最终可以深入到 IO 模型， 底层就是对应系统socket 的IO机制 -->

<h3 id="1-56-简述-IO-多路复用机制"><a href="#1-56-简述-IO-多路复用机制" class="headerlink" title="1.56 简述 IO 多路复用机制"></a>1.56 简述 IO 多路复用机制</h3><!-- TODO: 重点准备 -->

<h3 id="1-57-五种IO模型分别是什么？"><a href="#1-57-五种IO模型分别是什么？" class="headerlink" title="1.57 五种IO模型分别是什么？"></a>1.57 五种IO模型分别是什么？</h3><!-- TODO: 重点准备 -->

<h3 id="1-58-如何提升服务器的并发能力？"><a href="#1-58-如何提升服务器的并发能力？" class="headerlink" title="1.58 如何提升服务器的并发能力？"></a>1.58 如何提升服务器的并发能力？</h3><!-- TODO: 重点准备 -->

<h3 id="1-59-什么是-IO-多路服务用？"><a href="#1-59-什么是-IO-多路服务用？" class="headerlink" title="1.59 什么是 IO 多路服务用？"></a>1.59 什么是 IO 多路服务用？</h3><!-- TODO: 重点准备 -->

<h3 id="1-60-select-poll-epoll的区别"><a href="#1-60-select-poll-epoll的区别" class="headerlink" title="1.60 select/poll/epoll的区别"></a>1.60 select/poll/epoll的区别</h3><!-- TODO: 重点准备 -->

<h3 id="1-61-python中如何实现-IO-多路复用"><a href="#1-61-python中如何实现-IO-多路复用" class="headerlink" title="1.61 python中如何实现 IO 多路复用"></a>1.61 python中如何实现 IO 多路复用</h3><!-- TODO: 重点准备 -->

<h3 id="1-62-python常用的并发网络库"><a href="#1-62-python常用的并发网络库" class="headerlink" title="1.62 python常用的并发网络库"></a>1.62 python常用的并发网络库</h3><!-- TODO: 重点准备 -->

<h3 id="1-63-使用-tornado-构建微服务，-实现-restful-接口"><a href="#1-63-使用-tornado-构建微服务，-实现-restful-接口" class="headerlink" title="1.63 使用 tornado 构建微服务， 实现 restful 接口"></a>1.63 使用 tornado 构建微服务， 实现 restful 接口</h3><!-- TODO: 重点准备 -->

<h3 id="1-64-gevent-的并发实现原理"><a href="#1-64-gevent-的并发实现原理" class="headerlink" title="1.64 gevent 的并发实现原理"></a>1.64 gevent 的并发实现原理</h3><!-- TODO: 重点准备 -->

<h3 id="1-65-什么是-WSGI？-为什么需要-WSGI？"><a href="#1-65-什么是-WSGI？-为什么需要-WSGI？" class="headerlink" title="1.65 什么是 WSGI？ 为什么需要 WSGI？"></a>1.65 什么是 WSGI？ 为什么需要 WSGI？</h3><!-- TODO: 重点准备 -->

<h3 id="1-66-Django、Flask-和-Tornado-之间的异同？"><a href="#1-66-Django、Flask-和-Tornado-之间的异同？" class="headerlink" title="1.66 Django、Flask 和 Tornado 之间的异同？"></a>1.66 Django、Flask 和 Tornado 之间的异同？</h3><!-- TODO: 重点准备 -->

<h3 id="1-67-什么是-MVC？"><a href="#1-67-什么是-MVC？" class="headerlink" title="1.67 什么是 MVC？"></a>1.67 什么是 MVC？</h3><!-- TODO: 重点准备 -->

<h3 id="1-68-为什么要使用-ORM"><a href="#1-68-为什么要使用-ORM" class="headerlink" title="1.68 为什么要使用 ORM"></a>1.68 为什么要使用 ORM</h3><!-- TODO: 重点准备 -->

<h3 id="1-69-常见的-web-安全问题有哪些？"><a href="#1-69-常见的-web-安全问题有哪些？" class="headerlink" title="1.69 常见的 web 安全问题有哪些？"></a>1.69 常见的 web 安全问题有哪些？</h3><!-- TODO: 重点准备 -->

<h3 id="1-70-sql注入的原理是什么？如何防范？"><a href="#1-70-sql注入的原理是什么？如何防范？" class="headerlink" title="1.70 sql注入的原理是什么？如何防范？"></a>1.70 sql注入的原理是什么？如何防范？</h3><!-- TODO: 重点准备 -->

<h3 id="1-71-XSS攻击的原理是什么？如何防范？"><a href="#1-71-XSS攻击的原理是什么？如何防范？" class="headerlink" title="1.71 XSS攻击的原理是什么？如何防范？"></a>1.71 XSS攻击的原理是什么？如何防范？</h3><!-- TODO: 重点准备 -->

<h3 id="1-72-CSRF的作用是什么？"><a href="#1-72-CSRF的作用是什么？" class="headerlink" title="1.72 CSRF的作用是什么？"></a>1.72 CSRF的作用是什么？</h3><!-- TODO: 重点准备 -->

<h3 id="1-73-什么是前后端分离？有哪些优点？"><a href="#1-73-什么是前后端分离？有哪些优点？" class="headerlink" title="1.73 什么是前后端分离？有哪些优点？"></a>1.73 什么是前后端分离？有哪些优点？</h3><!-- TODO: 重点准备 -->

<h3 id="1-74-什么是-restful？"><a href="#1-74-什么是-restful？" class="headerlink" title="1.74 什么是 restful？"></a>1.74 什么是 restful？</h3><!-- TODO: 重点准备 -->

<h3 id="1-75-restful的准则是什么？"><a href="#1-75-restful的准则是什么？" class="headerlink" title="1.75 restful的准则是什么？"></a>1.75 restful的准则是什么？</h3><!-- TODO: 重点准备 -->

<h3 id="1-76-什么是restful-api？"><a href="#1-76-什么是restful-api？" class="headerlink" title="1.76 什么是restful api？"></a>1.76 什么是restful api？</h3><!-- TODO: 重点准备 -->

<h3 id="1-77-如何设计-restful-api？"><a href="#1-77-如何设计-restful-api？" class="headerlink" title="1.77 如何设计 restful api？"></a>1.77 如何设计 restful api？</h3><!-- TODO: 重点准备 -->

<h3 id="1-78-什么是-HTTPS？"><a href="#1-78-什么是-HTTPS？" class="headerlink" title="1.78 什么是 HTTPS？"></a>1.78 什么是 HTTPS？</h3><!-- TODO: 重点准备 -->

<h2 id="Part-2-操作系统相关问题"><a href="#Part-2-操作系统相关问题" class="headerlink" title="Part 2: 操作系统相关问题"></a>Part 2: 操作系统相关问题</h2><p><strong>本节内容主要与操作系统有关， 但是有部分问题也可以纳入编程语言的范畴， 比如进程、线程相关的问题。操作系统相关问题主要从两个层面准备，一是与上层应用开发相关的内容， 如内存管理机制；另一个是常用的命令。</strong></p>
<h3 id="2-1-进程、线程以及协程间的区别"><a href="#2-1-进程、线程以及协程间的区别" class="headerlink" title="2.1 进程、线程以及协程间的区别"></a>2.1 进程、线程以及协程间的区别</h3><p>进程： 资源分配的单位。分配了哪些资源呢？</p>
<p>线程： CPU调度的单位。</p>
<p>协程并不是系统层面的， 而是由程序控制的一种程序结构。</p>
<p>TODO: 资源共享和竞争的问题。  从语言的角度看， 进程、线程和协程的区别。</p>
<h3 id="2-2-线程间通信的方式"><a href="#2-2-线程间通信的方式" class="headerlink" title="2.2 线程间通信的方式"></a>2.2 线程间通信的方式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 延伸问题：</span></span><br><span class="line">python中， queue.Queue 为什么是线程安全的？</span><br><span class="line"></span><br><span class="line"><span class="section">#### 延伸思考：</span></span><br><span class="line">使用基于消息队列模式python多线程编程是多线程编程的一种最佳模式。</span><br></pre></td></tr></table></figure>



<p>线程共享同一份全局内存区域*， 所以线程之间可以方便， 快速地共享信息， 只需要将数据复制到共享变量（全局）中即可。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">共享的全局内存区域包括：</span><br><span class="line">初始化数据段， 未初始化数据段 以及 堆内存段</span><br><span class="line"></span><br><span class="line">相关知识点：</span><br><span class="line">进程的地址空间</span><br></pre></td></tr></table></figure>

<p>如果变量是只读的， 多个线程同时读取该变量不会有一致性问题， 但是， 当线程对变量有修改操作时， 就会有一致性的隐患， 所以要通过一些机制将变量的状态对所有线程同步， 确保线程不会访问到无效的变量内容。</p>
<p>线程间同步的方式主要有以下几种：</p>
<ul>
<li>互斥锁</li>
</ul>
<!-- 目前 python 编程时没怎么遇到会造成死锁的情况？因为使用到的多线程通常是执行相同的任务， 而且没有多个资源多个锁的情况 -->

<blockquote>
<p>互斥量的死锁:<br>一个线程需要访问两个或者更多不同的共享资源，而每个资源又有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发生死锁。死锁就是指多个线程/进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进。<br>死锁的处理策略：<br>1、预防死锁：破坏死锁产生的四个条件：互斥条件、不剥夺条件、请求和保持条件以及循环等待条件。<br>2、避免死锁：在每次进行资源分配前，应该计算此次分配资源的安全性，如果此次资源分配不会导致系统进入不安全状态，那么将资源分配给进程，否则等待。算法：银行家算法。<br>3、检测死锁：检测到死锁后通过资源剥夺、撤销进程、进程回退等方法解除死锁。<br>————————————————<br>版权声明：本文为CSDN博主「yexz」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/a987073381/java/article/details/52029070" target="_blank" rel="noopener">https://blog.csdn.net/a987073381/java/article/details/52029070</a></p>
</blockquote>
<ul>
<li>读写锁</li>
</ul>
<blockquote>
<p> 读写锁有三种状态：读模式下加锁， 写模式下加锁， 不加锁状态。一次只有一个线程可以占有写模式的读写锁， 但是多个线程可以同时占有读模式的读写锁。当读写锁是写加锁状态是， 在这个锁被解锁之前， 所有试图对这个锁加锁的线程都会被阻塞， 当读写锁在读加锁状态是， 所有试图以读模式它进行加锁的线程都可以得到访问权， 但是希望以写模式对锁进行加锁的线程都会阻塞， 直到所有的线程释放他们的锁为止。</p>
</blockquote>
<ul>
<li>条件变量</li>
</ul>
<blockquote>
<p>互斥量用于上锁， 条件变量则用于等待， 并且条件变量总是需要与互斥量一起使用， 运行线程以无竞争的方式等待特定的条件发生。</p>
<p>条件变量本身是由互斥量保护的， 线程在改变条件之前必须先锁住互斥量。其他线程在获得互斥量之前不会觉察到这种变化， 因为互斥量必须在锁定之后才能计算条件。</p>
</blockquote>
<ul>
<li>信号量</li>
</ul>
<blockquote>
<p>线程的信号量和进程的信号量类似， 使用线程的信号量可以高效地完成基于线程的资源计数。信号量实际上是一个非负的整数计数器， 用来实现对公共资源的控制。在公共资源增加的时候， 信号量就增加， 公共资源减少的时候， 信号量就减少；只用当信号量的值大于0的时候， 才能访问信号量所代表的公共资源。</p>
</blockquote>
<ul>
<li>自旋锁</li>
</ul>
<blockquote>
<p>自旋锁与互斥量类似， 但它不是通过休眠使进程阻塞， 而是在获取锁之前一直忙于等（自旋）阻塞状态。自旋锁可以用于以下情况：锁被持有的时间短， 而且线程并不希望在重新调度上花费太多的成本。</p>
</blockquote>
<ul>
<li>屏障</li>
</ul>
<blockquote>
<p>屏障是指用户可以协调多个线程并行工作的同步机制， 屏障允许每个线程等待， 直到所有的合作线程都达到某一点， 然后从该点继续执行。</p>
</blockquote>
<!-- TODO: python中的线程同步方式, python中的线程同步方式跟java中是不同的， 所以线程同步这块的通用知识还是要去看操作系统层面的 -->

<h3 id="2-3-进程间通信的方式"><a href="#2-3-进程间通信的方式" class="headerlink" title="2.3 进程间通信的方式"></a>2.3 进程间通信的方式</h3><h3 id="2-4-Linux内存管理机制"><a href="#2-4-Linux内存管理机制" class="headerlink" title="2.4 Linux内存管理机制"></a>2.4 Linux内存管理机制</h3><h3 id="2-5-Linux常用命令"><a href="#2-5-Linux常用命令" class="headerlink" title="2.5 Linux常用命令"></a>2.5 Linux常用命令</h3><h2 id="Part-3-数据库相关"><a href="#Part-3-数据库相关" class="headerlink" title="Part 3: 数据库相关"></a>Part 3: 数据库相关</h2><p><strong>数据库部分的问题主要准备 mysql 相关的问题以及缓存数据库相关的问题， 在此基础上如果有余力， 可以增加 elasticsearch 相关的问题。</strong></p>
<h3 id="3-1-mysql-事务原理、特性以及事务的并发控制"><a href="#3-1-mysql-事务原理、特性以及事务的并发控制" class="headerlink" title="3.1 mysql 事务原理、特性以及事务的并发控制"></a>3.1 mysql 事务原理、特性以及事务的并发控制</h3><h3 id="3-2-事务缺乏并发控制会产生哪些异常"><a href="#3-2-事务缺乏并发控制会产生哪些异常" class="headerlink" title="3.2 事务缺乏并发控制会产生哪些异常"></a>3.2 事务缺乏并发控制会产生哪些异常</h3><h3 id="3-3-事务的四种隔离级别"><a href="#3-3-事务的四种隔离级别" class="headerlink" title="3.3 事务的四种隔离级别"></a>3.3 事务的四种隔离级别</h3><h3 id="3-4-如何解决高并发场景下的插入重复"><a href="#3-4-如何解决高并发场景下的插入重复" class="headerlink" title="3.4 如何解决高并发场景下的插入重复"></a>3.4 如何解决高并发场景下的插入重复</h3><h3 id="3-5-什么是悲观锁"><a href="#3-5-什么是悲观锁" class="headerlink" title="3.5 什么是悲观锁"></a>3.5 什么是悲观锁</h3><h3 id="3-6-什么是乐观锁"><a href="#3-6-什么是乐观锁" class="headerlink" title="3.6 什么是乐观锁"></a>3.6 什么是乐观锁</h3><h3 id="3-7-乐观锁和悲观锁的选择"><a href="#3-7-乐观锁和悲观锁的选择" class="headerlink" title="3.7 乐观锁和悲观锁的选择"></a>3.7 乐观锁和悲观锁的选择</h3><h3 id="3-8-mysql-常用数据类型"><a href="#3-8-mysql-常用数据类型" class="headerlink" title="3.8 mysql 常用数据类型"></a>3.8 mysql 常用数据类型</h3><h3 id="3-9-mysql数据库引擎"><a href="#3-9-mysql数据库引擎" class="headerlink" title="3.9 mysql数据库引擎"></a>3.9 mysql数据库引擎</h3><h3 id="3-10-什么是索引"><a href="#3-10-什么是索引" class="headerlink" title="3.10 什么是索引"></a>3.10 什么是索引</h3><h3 id="3-11-mysql索引的数据结构"><a href="#3-11-mysql索引的数据结构" class="headerlink" title="3.11 mysql索引的数据结构"></a>3.11 mysql索引的数据结构</h3><h3 id="3-12-mysql的索引类型"><a href="#3-12-mysql的索引类型" class="headerlink" title="3.12 mysql的索引类型"></a>3.12 mysql的索引类型</h3><h3 id="3-13-什么时候创建索引？有什么需要注意的？"><a href="#3-13-什么时候创建索引？有什么需要注意的？" class="headerlink" title="3.13 什么时候创建索引？有什么需要注意的？"></a>3.13 什么时候创建索引？有什么需要注意的？</h3><h3 id="3-14-索引什么时候失效"><a href="#3-14-索引什么时候失效" class="headerlink" title="3.14 索引什么时候失效"></a>3.14 索引什么时候失效</h3><h3 id="3-15-什么是聚集索引，-什么是非聚集索引"><a href="#3-15-什么是聚集索引，-什么是非聚集索引" class="headerlink" title="3.15 什么是聚集索引， 什么是非聚集索引"></a>3.15 什么是聚集索引， 什么是非聚集索引</h3><h3 id="3-16-如何排查慢查询"><a href="#3-16-如何排查慢查询" class="headerlink" title="3.16 如何排查慢查询"></a>3.16 如何排查慢查询</h3><h3 id="3-17-什么是内连接、外连接和全连接"><a href="#3-17-什么是内连接、外连接和全连接" class="headerlink" title="3.17 什么是内连接、外连接和全连接"></a>3.17 什么是内连接、外连接和全连接</h3><h3 id="3-18-缓存的使用场景"><a href="#3-18-缓存的使用场景" class="headerlink" title="3.18 缓存的使用场景"></a>3.18 缓存的使用场景</h3><h3 id="3-19-redis-和-memcached-的主要区别"><a href="#3-19-redis-和-memcached-的主要区别" class="headerlink" title="3.19 redis  和 memcached 的主要区别"></a>3.19 redis  和 memcached 的主要区别</h3><h3 id="3-20-请简述-redis-常用数据类型和使用场景"><a href="#3-20-请简述-redis-常用数据类型和使用场景" class="headerlink" title="3.20 请简述 redis 常用数据类型和使用场景"></a>3.20 请简述 redis 常用数据类型和使用场景</h3><h3 id="3-21-redis-数据类型的内置实现"><a href="#3-21-redis-数据类型的内置实现" class="headerlink" title="3.21 redis 数据类型的内置实现"></a>3.21 redis 数据类型的内置实现</h3><h3 id="3-22-redis-有哪些持久化方式"><a href="#3-22-redis-有哪些持久化方式" class="headerlink" title="3.22 redis 有哪些持久化方式"></a>3.22 redis 有哪些持久化方式</h3><h3 id="3-23-什么是-redis-事务"><a href="#3-23-什么是-redis-事务" class="headerlink" title="3.23 什么是 redis 事务"></a>3.23 什么是 redis 事务</h3><h3 id="3-24-redis-如何实现分布式锁"><a href="#3-24-redis-如何实现分布式锁" class="headerlink" title="3.24 redis 如何实现分布式锁"></a>3.24 redis 如何实现分布式锁</h3><h3 id="3-25-使用缓存的模式"><a href="#3-25-使用缓存的模式" class="headerlink" title="3.25 使用缓存的模式"></a>3.25 使用缓存的模式</h3><h3 id="3-26-什么是缓存穿透"><a href="#3-26-什么是缓存穿透" class="headerlink" title="3.26 什么是缓存穿透"></a>3.26 什么是缓存穿透</h3><h3 id="3-27-什么是缓存击穿"><a href="#3-27-什么是缓存击穿" class="headerlink" title="3.27 什么是缓存击穿"></a>3.27 什么是缓存击穿</h3><h3 id="3-28-什么是缓存雪崩"><a href="#3-28-什么是缓存雪崩" class="headerlink" title="3.28 什么是缓存雪崩"></a>3.28 什么是缓存雪崩</h3><h3 id="3-29-为什么-mysql-数据库的主键使用自增的整数比较好，-使用uuid可以吗，-如果是分布式系统下怎么生成数据库的自增id"><a href="#3-29-为什么-mysql-数据库的主键使用自增的整数比较好，-使用uuid可以吗，-如果是分布式系统下怎么生成数据库的自增id" class="headerlink" title="3.29 为什么 mysql 数据库的主键使用自增的整数比较好， 使用uuid可以吗， 如果是分布式系统下怎么生成数据库的自增id"></a>3.29 为什么 mysql 数据库的主键使用自增的整数比较好， 使用uuid可以吗， 如果是分布式系统下怎么生成数据库的自增id</h3><h3 id="3-30-基于-redis-编写代码实现一个简单的分布式锁"><a href="#3-30-基于-redis-编写代码实现一个简单的分布式锁" class="headerlink" title="3.30 基于 redis 编写代码实现一个简单的分布式锁"></a>3.30 基于 redis 编写代码实现一个简单的分布式锁</h3><h2 id="Part-4-网络协议"><a href="#Part-4-网络协议" class="headerlink" title="Part 4: 网络协议"></a>Part 4: 网络协议</h2><h3 id="4-1-浏览器输入一个-URL-中间经历的过程"><a href="#4-1-浏览器输入一个-URL-中间经历的过程" class="headerlink" title="4.1 浏览器输入一个 URL 中间经历的过程"></a>4.1 浏览器输入一个 URL 中间经历的过程</h3><ol>
<li>DNS 解析地址</li>
<li>建立 TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>接收响应、获取静态资源</li>
<li>关闭连接</li>
<li>渲染 HTML</li>
</ol>
<h3 id="4-2-网络的分层模型"><a href="#4-2-网络的分层模型" class="headerlink" title="4.2 网络的分层模型"></a>4.2 网络的分层模型</h3><!-- TODO: 重点准备， 实际开发过程中使用的是四层（五层）模型，但是对于理解网络结构而言，OSI七层模型划分更清晰 -->

<h3 id="4-3-TCP-的握手过程"><a href="#4-3-TCP-的握手过程" class="headerlink" title="4.3 TCP 的握手过程"></a>4.3 TCP 的握手过程</h3><!-- TODO: 重点准备 -->

<h3 id="4-4-TCP-的挥手过程"><a href="#4-4-TCP-的挥手过程" class="headerlink" title="4.4 TCP 的挥手过程"></a>4.4 TCP 的挥手过程</h3><!-- TODO: 重点准备 -->

<h3 id="4-5-TCP-跟-UDP-的差别"><a href="#4-5-TCP-跟-UDP-的差别" class="headerlink" title="4.5 TCP 跟 UDP 的差别"></a>4.5 TCP 跟 UDP 的差别</h3><!-- TODO: 重点准备 -->

<h3 id="4-6-HTTP-请求由哪些部分组成"><a href="#4-6-HTTP-请求由哪些部分组成" class="headerlink" title="4.6 HTTP 请求由哪些部分组成"></a>4.6 HTTP 请求由哪些部分组成</h3><h3 id="4-7-常见的-HTTP-响应状态码"><a href="#4-7-常见的-HTTP-响应状态码" class="headerlink" title="4.7 常见的 HTTP 响应状态码"></a>4.7 常见的 HTTP 响应状态码</h3><h3 id="4-8-什么是幂等方法，-哪些-HTTP-方法是幂等的"><a href="#4-8-什么是幂等方法，-哪些-HTTP-方法是幂等的" class="headerlink" title="4.8 什么是幂等方法， 哪些 HTTP 方法是幂等的"></a>4.8 什么是幂等方法， 哪些 HTTP 方法是幂等的</h3><h3 id="4-9-HTTP-的长链接"><a href="#4-9-HTTP-的长链接" class="headerlink" title="4.9 HTTP 的长链接"></a>4.9 HTTP 的长链接</h3><h3 id="4-10-GET-POST-PUT-DELETE-方法"><a href="#4-10-GET-POST-PUT-DELETE-方法" class="headerlink" title="4.10 GET/POST/PUT/DELETE 方法"></a>4.10 GET/POST/PUT/DELETE 方法</h3><h3 id="4-11-长链接时如何区分不同的请求？"><a href="#4-11-长链接时如何区分不同的请求？" class="headerlink" title="4.11 长链接时如何区分不同的请求？"></a>4.11 长链接时如何区分不同的请求？</h3><h3 id="4-12-cookie-和-session-的异同"><a href="#4-12-cookie-和-session-的异同" class="headerlink" title="4.12 cookie 和 session 的异同"></a>4.12 cookie 和 session 的异同</h3><h2 id="Part-5-系统设计"><a href="#Part-5-系统设计" class="headerlink" title="Part 5: 系统设计"></a>Part 5: 系统设计</h2><h3 id="5-1-什么是系统设计？"><a href="#5-1-什么是系统设计？" class="headerlink" title="5.1 什么是系统设计？"></a>5.1 什么是系统设计？</h3><h3 id="5-2-系统如何进行扩展？如用户增多之后，-qps上来了，-现有设计不再满足使用需求了，-要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了，-现有容量不够了）？"><a href="#5-2-系统如何进行扩展？如用户增多之后，-qps上来了，-现有设计不再满足使用需求了，-要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了，-现有容量不够了）？" class="headerlink" title="5.2 系统如何进行扩展？如用户增多之后， qps上来了， 现有设计不再满足使用需求了， 要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了， 现有容量不够了）？"></a>5.2 系统如何进行扩展？如用户增多之后， qps上来了， 现有设计不再满足使用需求了， 要如何对系统进行扩展（程序性能的扩展）？数据规模的扩展（数据存储多了， 现有容量不够了）？</h3><h3 id="5-3-故障如何处理？单点失效、多点失效和雪崩问题？"><a href="#5-3-故障如何处理？单点失效、多点失效和雪崩问题？" class="headerlink" title="5.3 故障如何处理？单点失效、多点失效和雪崩问题？"></a>5.3 故障如何处理？单点失效、多点失效和雪崩问题？</h3><h3 id="5-4-设计一个短网址系统"><a href="#5-4-设计一个短网址系统" class="headerlink" title="5.4 设计一个短网址系统"></a>5.4 设计一个短网址系统</h3><h3 id="5-5-设计一个秒杀系统"><a href="#5-5-设计一个秒杀系统" class="headerlink" title="5.5 设计一个秒杀系统"></a>5.5 设计一个秒杀系统</h3>
                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/05/08/Python%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" data-id="ckabac773000ko0ug7cylh9xs" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E6%8C%87%E5%8D%97/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            [数据结构和算法] 指南
          
        </div>
      </a>
    
    
      <a href="/2020/05/08/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">面试问题整理</div>
      </a>
    
  </nav>


            

                
                    
                        
                            

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 小夜灯</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="小夜灯"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>